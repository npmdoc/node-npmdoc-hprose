<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/hprose/hprose-nodejs"

    >hprose (v2.0.42)</a>
</h1>
<h4>hprose for node.js</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose">module hprose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.BytesIO">
            function <span class="apidocSignatureSpan">hprose.</span>BytesIO
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Client">
            function <span class="apidocSignatureSpan">hprose.</span>Client
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Completer">
            function <span class="apidocSignatureSpan">hprose.</span>Completer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Future">
            function <span class="apidocSignatureSpan">hprose.</span>Future
            <span class="apidocSignatureSpan">(computation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpClient">
            function <span class="apidocSignatureSpan">hprose.</span>HttpClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpServer">
            function <span class="apidocSignatureSpan">hprose.</span>HttpServer
            <span class="apidocSignatureSpan">(port, hostname, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpService">
            function <span class="apidocSignatureSpan">hprose.</span>HttpService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCClientFilter">
            function <span class="apidocSignatureSpan">hprose.</span>JSONRPCClientFilter
            <span class="apidocSignatureSpan">(version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCServiceFilter">
            function <span class="apidocSignatureSpan">hprose.</span>JSONRPCServiceFilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.RawReader">
            function <span class="apidocSignatureSpan">hprose.</span>RawReader
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Reader">
            function <span class="apidocSignatureSpan">hprose.</span>Reader
            <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Server">
            function <span class="apidocSignatureSpan">hprose.</span>Server
            <span class="apidocSignatureSpan">(uri, tlsOptions, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Service">
            function <span class="apidocSignatureSpan">hprose.</span>Service
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketClient">
            function <span class="apidocSignatureSpan">hprose.</span>SocketClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketServer">
            function <span class="apidocSignatureSpan">hprose.</span>SocketServer
            <span class="apidocSignatureSpan">(options, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketService">
            function <span class="apidocSignatureSpan">hprose.</span>SocketService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.TcpClient">
            function <span class="apidocSignatureSpan">hprose.</span>TcpClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.TcpServer">
            function <span class="apidocSignatureSpan">hprose.</span>TcpServer
            <span class="apidocSignatureSpan">(options, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.TimeoutError">
            function <span class="apidocSignatureSpan">hprose.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.UnixClient">
            function <span class="apidocSignatureSpan">hprose.</span>UnixClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.UnixServer">
            function <span class="apidocSignatureSpan">hprose.</span>UnixServer
            <span class="apidocSignatureSpan">(options, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketClient">
            function <span class="apidocSignatureSpan">hprose.</span>WebSocketClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketServer">
            function <span class="apidocSignatureSpan">hprose.</span>WebSocketServer
            <span class="apidocSignatureSpan">(options, tlsOptions, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketService">
            function <span class="apidocSignatureSpan">hprose.</span>WebSocketService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Writer">
            function <span class="apidocSignatureSpan">hprose.</span>Writer
            <span class="apidocSignatureSpan">(stream, simple)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.co">
            function <span class="apidocSignatureSpan">hprose.</span>co
            <span class="apidocSignatureSpan">(gen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.deferred">
            function <span class="apidocSignatureSpan">hprose.</span>deferred
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.generic">
            function <span class="apidocSignatureSpan">hprose.</span>generic
            <span class="apidocSignatureSpan">(method)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.isObjectEmpty">
            function <span class="apidocSignatureSpan">hprose.</span>isObjectEmpty
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.promisify">
            function <span class="apidocSignatureSpan">hprose.</span>promisify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.register">
            function <span class="apidocSignatureSpan">hprose.</span>register
            <span class="apidocSignatureSpan">(cls, alias)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.rejected">
            function <span class="apidocSignatureSpan">hprose.</span>rejected
            <span class="apidocSignatureSpan">(e)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.resolved">
            function <span class="apidocSignatureSpan">hprose.</span>resolved
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.serialize">
            function <span class="apidocSignatureSpan">hprose.</span>serialize
            <span class="apidocSignatureSpan">(value, simple)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.thunkify">
            function <span class="apidocSignatureSpan">hprose.</span>thunkify
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.toArray">
            function <span class="apidocSignatureSpan">hprose.</span>toArray
            <span class="apidocSignatureSpan">(arrayLikeObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.toBinaryString">
            function <span class="apidocSignatureSpan">hprose.</span>toBinaryString
            <span class="apidocSignatureSpan">(bytes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.toUint8Array">
            function <span class="apidocSignatureSpan">hprose.</span>toUint8Array
            <span class="apidocSignatureSpan">(bs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.unserialize">
            function <span class="apidocSignatureSpan">hprose.</span>unserialize
            <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.wrap">
            function <span class="apidocSignatureSpan">hprose.</span>wrap
            <span class="apidocSignatureSpan">(handler, thisArg)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">hprose.</span>Normal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">hprose.</span>Raw</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">hprose.</span>RawWithEndTag</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">hprose.</span>Serialized</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>ClassManager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>Formatter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>JSONRPCClientFilter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>JSONRPCServiceFilter.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>Reader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>ResultMode</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>Tags</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>TimeoutError.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>client</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>common</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>filter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>io</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>regenerator_runtime</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.</span>server</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.Client">module hprose.Client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Client.Client">
            function <span class="apidocSignatureSpan">hprose.</span>Client
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Client.super_">
            function <span class="apidocSignatureSpan">hprose.Client.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.Formatter">module hprose.Formatter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Formatter.serialize">
            function <span class="apidocSignatureSpan">hprose.Formatter.</span>serialize
            <span class="apidocSignatureSpan">(value, simple)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Formatter.unserialize">
            function <span class="apidocSignatureSpan">hprose.Formatter.</span>unserialize
            <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.HttpClient">module hprose.HttpClient</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpClient.HttpClient">
            function <span class="apidocSignatureSpan">hprose.</span>HttpClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpClient.super_">
            function <span class="apidocSignatureSpan">hprose.HttpClient.</span>super_
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.HttpServer">module hprose.HttpServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpServer.HttpServer">
            function <span class="apidocSignatureSpan">hprose.</span>HttpServer
            <span class="apidocSignatureSpan">(port, hostname, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpServer.super_">
            function <span class="apidocSignatureSpan">hprose.HttpServer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.HttpService">module hprose.HttpService</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpService.HttpService">
            function <span class="apidocSignatureSpan">hprose.</span>HttpService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.HttpService.super_">
            function <span class="apidocSignatureSpan">hprose.HttpService.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.JSONRPCClientFilter">module hprose.JSONRPCClientFilter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCClientFilter.JSONRPCClientFilter">
            function <span class="apidocSignatureSpan">hprose.</span>JSONRPCClientFilter
            <span class="apidocSignatureSpan">(version)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.JSONRPCClientFilter.prototype">module hprose.JSONRPCClientFilter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCClientFilter.prototype.inputFilter">
            function <span class="apidocSignatureSpan">hprose.JSONRPCClientFilter.prototype.</span>inputFilter
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCClientFilter.prototype.outputFilter">
            function <span class="apidocSignatureSpan">hprose.JSONRPCClientFilter.prototype.</span>outputFilter
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.JSONRPCServiceFilter">module hprose.JSONRPCServiceFilter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCServiceFilter.JSONRPCServiceFilter">
            function <span class="apidocSignatureSpan">hprose.</span>JSONRPCServiceFilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.JSONRPCServiceFilter.prototype">module hprose.JSONRPCServiceFilter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCServiceFilter.prototype.inputFilter">
            function <span class="apidocSignatureSpan">hprose.JSONRPCServiceFilter.prototype.</span>inputFilter
            <span class="apidocSignatureSpan">(data, context)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.JSONRPCServiceFilter.prototype.outputFilter">
            function <span class="apidocSignatureSpan">hprose.JSONRPCServiceFilter.prototype.</span>outputFilter
            <span class="apidocSignatureSpan">(data, context)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.Reader">module hprose.Reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Reader.Reader">
            function <span class="apidocSignatureSpan">hprose.</span>Reader
            <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.Reader.prototype">module hprose.Reader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Reader.prototype.constructor">
            function <span class="apidocSignatureSpan">hprose.Reader.prototype.</span>constructor
            <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.Service">module hprose.Service</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Service.Service">
            function <span class="apidocSignatureSpan">hprose.</span>Service
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.Service.super_">
            function <span class="apidocSignatureSpan">hprose.Service.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.SocketClient">module hprose.SocketClient</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketClient.SocketClient">
            function <span class="apidocSignatureSpan">hprose.</span>SocketClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketClient.super_">
            function <span class="apidocSignatureSpan">hprose.SocketClient.</span>super_
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.SocketServer">module hprose.SocketServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketServer.SocketServer">
            function <span class="apidocSignatureSpan">hprose.</span>SocketServer
            <span class="apidocSignatureSpan">(options, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketServer.super_">
            function <span class="apidocSignatureSpan">hprose.SocketServer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.SocketService">module hprose.SocketService</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketService.SocketService">
            function <span class="apidocSignatureSpan">hprose.</span>SocketService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.SocketService.super_">
            function <span class="apidocSignatureSpan">hprose.SocketService.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.TimeoutError">module hprose.TimeoutError</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.TimeoutError.TimeoutError">
            function <span class="apidocSignatureSpan">hprose.</span>TimeoutError
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.TimeoutError.prototype">module hprose.TimeoutError.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.TimeoutError.prototype.constructor">
            function <span class="apidocSignatureSpan">hprose.TimeoutError.prototype.</span>constructor
            <span class="apidocSignatureSpan">(message)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.WebSocketClient">module hprose.WebSocketClient</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketClient.WebSocketClient">
            function <span class="apidocSignatureSpan">hprose.</span>WebSocketClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketClient.super_">
            function <span class="apidocSignatureSpan">hprose.WebSocketClient.</span>super_
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.WebSocketServer">module hprose.WebSocketServer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketServer.WebSocketServer">
            function <span class="apidocSignatureSpan">hprose.</span>WebSocketServer
            <span class="apidocSignatureSpan">(options, tlsOptions, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketServer.super_">
            function <span class="apidocSignatureSpan">hprose.WebSocketServer.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.WebSocketService">module hprose.WebSocketService</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketService.WebSocketService">
            function <span class="apidocSignatureSpan">hprose.</span>WebSocketService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.WebSocketService.super_">
            function <span class="apidocSignatureSpan">hprose.WebSocketService.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.client">module hprose.client</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.client.Client">
            function <span class="apidocSignatureSpan">hprose.client.</span>Client
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.client.HttpClient">
            function <span class="apidocSignatureSpan">hprose.client.</span>HttpClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.client.SocketClient">
            function <span class="apidocSignatureSpan">hprose.client.</span>SocketClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.client.TcpClient">
            function <span class="apidocSignatureSpan">hprose.client.</span>TcpClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.client.UnixClient">
            function <span class="apidocSignatureSpan">hprose.client.</span>UnixClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.client.WebSocketClient">
            function <span class="apidocSignatureSpan">hprose.client.</span>WebSocketClient
            <span class="apidocSignatureSpan">(uri, functions, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.co">module hprose.co</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.co.co">
            function <span class="apidocSignatureSpan">hprose.</span>co
            <span class="apidocSignatureSpan">(gen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.co.wrap">
            function <span class="apidocSignatureSpan">hprose.co.</span>wrap
            <span class="apidocSignatureSpan">(handler, thisArg)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.common">module hprose.common</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.common.Completer">
            function <span class="apidocSignatureSpan">hprose.common.</span>Completer
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.common.Future">
            function <span class="apidocSignatureSpan">hprose.common.</span>Future
            <span class="apidocSignatureSpan">(computation)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.common.</span>ResultMode</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.filter">module hprose.filter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.filter.JSONRPCClientFilter">
            function <span class="apidocSignatureSpan">hprose.filter.</span>JSONRPCClientFilter
            <span class="apidocSignatureSpan">(version)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.filter.JSONRPCServiceFilter">
            function <span class="apidocSignatureSpan">hprose.filter.</span>JSONRPCServiceFilter
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.io">module hprose.io</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.io.BytesIO">
            function <span class="apidocSignatureSpan">hprose.io.</span>BytesIO
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.io.RawReader">
            function <span class="apidocSignatureSpan">hprose.io.</span>RawReader
            <span class="apidocSignatureSpan">(stream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.io.Reader">
            function <span class="apidocSignatureSpan">hprose.io.</span>Reader
            <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.io.Writer">
            function <span class="apidocSignatureSpan">hprose.io.</span>Writer
            <span class="apidocSignatureSpan">(stream, simple)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.io.</span>ClassManager</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.io.</span>Formatter</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">hprose.io.</span>Tags</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.regenerator_runtime">module hprose.regenerator_runtime</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.regenerator_runtime.async">
            function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>async
            <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.regenerator_runtime.awrap">
            function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>awrap
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.regenerator_runtime.isGeneratorFunction">
            function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>isGeneratorFunction
            <span class="apidocSignatureSpan">(genFun)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.regenerator_runtime.keys">
            function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>keys
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.regenerator_runtime.mark">
            function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>mark
            <span class="apidocSignatureSpan">(genFun)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.regenerator_runtime.values">
            function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>values
            <span class="apidocSignatureSpan">(iterable)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.regenerator_runtime.wrap">
            function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>wrap
            <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.hprose.server">module hprose.server</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.HttpServer">
            function <span class="apidocSignatureSpan">hprose.server.</span>HttpServer
            <span class="apidocSignatureSpan">(port, hostname, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.HttpService">
            function <span class="apidocSignatureSpan">hprose.server.</span>HttpService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.Server">
            function <span class="apidocSignatureSpan">hprose.server.</span>Server
            <span class="apidocSignatureSpan">(uri, tlsOptions, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.Service">
            function <span class="apidocSignatureSpan">hprose.server.</span>Service
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.SocketServer">
            function <span class="apidocSignatureSpan">hprose.server.</span>SocketServer
            <span class="apidocSignatureSpan">(options, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.SocketService">
            function <span class="apidocSignatureSpan">hprose.server.</span>SocketService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.TcpServer">
            function <span class="apidocSignatureSpan">hprose.server.</span>TcpServer
            <span class="apidocSignatureSpan">(options, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.UnixServer">
            function <span class="apidocSignatureSpan">hprose.server.</span>UnixServer
            <span class="apidocSignatureSpan">(options, tlsOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.WebSocketServer">
            function <span class="apidocSignatureSpan">hprose.server.</span>WebSocketServer
            <span class="apidocSignatureSpan">(options, tlsOptions, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.hprose.server.WebSocketService">
            function <span class="apidocSignatureSpan">hprose.server.</span>WebSocketService
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose" id="apidoc.module.hprose">module hprose</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.BytesIO" id="apidoc.element.hprose.BytesIO">
        function <span class="apidocSignatureSpan">hprose.</span>BytesIO
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n/a</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Client" id="apidoc.element.hprose.Client">
        function <span class="apidocSignatureSpan">hprose.</span>Client
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(uri, functions, settings) {
    EventEmitter.call(this);
    this.on(&#x27;error&#x27;, noop);

    // private members
    var _uri,
        _uriList                = [],
        _index                  = -1,
        _byref                  = false,
        _simple                 = false,
        _timeout                = 30000,
        _retry                  = 10,
        _idempotent             = false,
        _failswitch             = false,
        _failround              = 0,
        _lock                   = false,
        _tasks                  = [],
        _useHarmonyMap          = false,
        _onerror                = noop,
        _onfailswitch           = noop,
        _filters                = [],
        _batch                  = false,
        _batches                = [],
        _ready                  = new Future(),
        _topics                 = Object.create(null),
        _id                     = null,
        _keepAlive              = true,
        _invokeHandler          = invokeHandler,
        _batchInvokeHandler     = batchInvokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _batchInvokeHandlers    = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],
        _options                = Object.create(null),

        self = this;

    function outputFilter(request, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            request = _filters[i].outputFilter(request, context);
        }
        return request;
    }

    function inputFilter(response, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            response = _filters[i].inputFilter(response, context);
        }
        return response;
    }

    function beforeFilterHandler(request, context) {
        request = outputFilter(request, context);
        return _afterFilterHandler(request, context)
        .then(function(response) {
            if (context.oneway) { return; }
            return inputFilter(response, context);
        });
    }

    function afterFilterHandler(request, context) {
         return self.sendAndReceive(request, context).catchError(function(e) {
             var response = retry(request, context);
             if (response !== null) {
                 return response;
             }
             throw e;
        });
    }

    function sendAndReceive(request, context, onsuccess, onerror) {
        _beforeFilterHandler(request, context).then(onsuccess, onerror);
    }

    function failswitch() {
        var n = _uriList.length;
        if (n &#x3e; 1) {
            var i = _index + 1;
            if (i &#x3e;= n) {
                i = 0;
                _failround++;
            }
            _index = i;
            _uri = _uriList[_index];
        }
        else {
            _failround++;
        }
        _onfailswitch(self);
        self.emit(&#x27;failswitch&#x27;, self);
    }

    function retry(data, context) {
        if (context.failswitch) {
            failswitch();
        }
        if (context.idempotent &#x26;&#x26; (context.retried &#x3c; context.retry)) {
            var interval = ++context.retried * 500;
            if (context.failswitch) {
                interval -= (_uriList.length - 1) * 500;
            }
            if (interval &#x3e; 5000) {
                interval = 5000;
            }
            if (interval &#x3e; 0) {
                return Future.delayed(interval, function() {
                    return afterFilterHandler(data, context);
                });
            }
            else {
                return afterFilterHandler(data, context);
            }
        }
        return null;
    }

    function initService(stub) {
        var context = {
            retry: _retry,
            retried: 0,
            idempotent: true,
            failswitch: true,
            timeout: _timeout,
            client: self,
            userdata: {}
        };
        var onsuccess = function(data) {
            var error = nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Completer" id="apidoc.element.hprose.Completer">
        function <span class="apidocSignatureSpan">hprose.</span>Completer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Completer() {
    var future = new Future();
    Object.defineProperties(this, {
        future: { value: future },
        complete: { value: future.resolve },
        completeError: { value: future.reject },
        isCompleted: { get: function() {
            return ( future._state !== PENDING );
        } }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Future" id="apidoc.element.hprose.Future">
        function <span class="apidocSignatureSpan">hprose.</span>Future
        <span class="apidocSignatureSpan">(computation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Future(computation) {
    var self = this;
    Object.defineProperties(this, {
        _subscribers: { value: [] },
        resolve: { value: this.resolve.bind(this) },
        reject: { value: this.reject.bind(this) }
    });
    if (typeof computation === &#x27;function&#x27;) {
        process.nextTick(function() {
            try {
                self.resolve(computation());
            }
            catch(e) {
                self.reject(e);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.HttpClient" id="apidoc.element.hprose.HttpClient">
        function <span class="apidocSignatureSpan">hprose.</span>HttpClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpClient(uri, functions, settings) {
    if (this.constructor !== HttpClient) {
        return new HttpClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);
    var _header = Object.create(null);

    var self = this;

    function getRequestHeader(headers) {
        var header = Object.create(null);
        var name, value;
        for (name in _header) {
            header[name] = _header[name];
        }
        if (headers) {
            for (name in headers) {
                value = headers[name];
                if (Array.isArray(value)) {
                    header[name] = value.join(&#x27;, &#x27;);
                }
                else {
                    header[name] = value;
                }
            }
        }
        return header;
    }

    function send(request, future, context) {
        request = BytesIO.toBuffer(request);
        var options = parse(self.uri);
        var protocol = options.protocol;
        var client;
        var secure;
        if (protocol === &#x27;http:&#x27;) {
            client = http;
            secure = false;
        }
        else if (protocol === &#x27;https:&#x27;) {
            client = https;
            secure = true;
        }
        else {
            throw new Error(&#x27;Unsupported &#x27; + protocol + &#x27; protocol!&#x27;);
        }
        options.keepAlive = self.keepAlive;
        for (var key in self.options) {
            options[key] = self.options[key];
        }
        options.method = &#x27;POST&#x27;;
        options.headers = getRequestHeader(context.httpHeader);
        options.headers[&#x27;Content-Length&#x27;] = request.length;
        var cookie = getCookie(options.host, options.path, secure);
        if (cookie !== &#x27;&#x27;) {
            options.headers.Cookie = cookie;
        }
        var req = client.request(options, function(resp) {
            context.httpHeader = resp.headers;
            var bytes = new BytesIO();
            resp.on(&#x27;data&#x27;, function(data) { bytes.write(data); });
            resp.on(&#x27;end&#x27;, function() {
                if (resp.statusCode === 200) {
                    future.resolve(bytes.bytes);
                }
                else {
                    future.reject(new Error(resp.statusCode + &#x27;:&#x27; + bytes.toString()));
                }
            });
            resp.on(&#x27;error&#x27;, future.reject);
            if (resp.statusCode === 200) {
                setCookie(resp.headers, options.host);
            }
        });
        req.on(&#x27;error&#x27;, future.reject);
        req.end(request);
        return req;
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        var req = send(request, future, context);
        if (context.timeout &#x3e; 0) {
            future = future.timeout(context.timeout).catchError(function(e) {
                req.removeAllListeners(&#x27;error&#x27;);
                req.on(&#x27;error&#x27;, noop);
                req.abort();
                throw e;
            },
            function(e) {
                return e instanceof TimeoutError;
            });
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    function setHeader(name, value) {
        if (name.toLowerCase() !== &#x27;content-type&#x27; &#x26;&#x26;
            name.toLowerCase() !== &#x27;content-length&#x27; &#x26;&#x26;
            name.toLowerCase() !== &#x27;host&#x27;) {
            if (value) {
                _header[name] = value;
            }
            else {
                delete _header[name];
            }
        }
    }

    Object.defineProperties(this, {
        setHeader: { value: setHeader },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.HttpServer" id="apidoc.element.hprose.HttpServer">
        function <span class="apidocSignatureSpan">hprose.</span>HttpServer
        <span class="apidocSignatureSpan">(port, hostname, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpServer(port, hostname, tlsOptions) {
    HttpService.call(this);

    var self = this;
    var server = (tlsOptions ?
        https.createServer(tlsOptions, self.handle) :
        http.createServer(self.handle));

    server.on(&#x27;clientError&#x27;, function (e, socket) {
        var context = { server: server, socket: socket, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(port, hostname);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.HttpService" id="apidoc.element.hprose.HttpService">
        function <span class="apidocSignatureSpan">hprose.</span>HttpService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpService() {
    Service.call(this);

    var _onSendHeader = null;
    var _crossDomain = true;
    var _P3P = true;
    var _get = true;
    var _origins = {};
    var _origincount = 0;
    var _crossDomainXmlFile = null;
    var _crossDomainXmlContent = null;
    var _clientAccessPolicyXmlFile = null;
    var _clientAccessPolicyXmlContent = null;
    var _lastModified = (new Date()).toUTCString();
    var _etag = &#x27;&#x22;&#x27; + Math.floor(Math.random() * 2147483647).toString(16) +
                &#x27;:&#x27; + Math.floor(Math.random() * 2147483647).toString(16) + &#x27;&#x22;&#x27;;

    var self = this;

    function getSendHeader() {
        return _onSendHeader;
    }

    function setSendHeader(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendHeader = value;
        }
        else {
            throw new Error(&#x27;onSendHeader must be a function or null.&#x27;);
        }
    }

    function crossDomainXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/crossdomain.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _crossDomainXmlContent.length);
                response.write(_crossDomainXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function clientAccessPolicyXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/clientaccesspolicy.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _clientAccessPolicyXmlContent.length);
                response.write(_clientAccessPolicyXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function sendHeader(context) {
        var resp = context.response;
        resp.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);
        if (_P3P) {
            resp.setHeader(&#x27;P3P&#x27;,
                &#x27;CP=&#x22;CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi &#x27; +
                &#x27;CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL &#x27; +
                &#x27;UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE GOV&#x22;&#x27;);
        }
        if (_crossDomain) {
            var origin = context.request.headers.origin;
            if (origin &#x26;&#x26; origin !== &#x27;null&#x27;) {
                if (_origincount === 0 || _origins[origin]) {
                    resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin);
                    resp.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);
                }
            }
            else {
                resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);
            }
        }
        self.emit(&#x27;sendHeader&#x27;, context);
        if (_onSendHeader !== null) {
            _onSendHeader(context);
        }
    }

    function isCrossDomainEnabled() {
        return _crossDomain;
    }

    function setCrossDomainEnabled(value) {
        _crossDomain = !!value;
    }

    function isP3PEnabled() {
        return _P3P;
    }

    function setP3PEnabled(value) {
        _P3P = !!value;
    }

    function isGetEnabled() {
        return _get;
    }

    function setGetEnabled(value) {
        _get = !!value;
    }

    function addAccessControlAllowOrigin(origin) {
        if (!_origins[origin]) {
            _origins[origin] = true;
            _origincount++;
        }
    }

    function removeAcces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.JSONRPCClientFilter" id="apidoc.element.hprose.JSONRPCClientFilter">
        function <span class="apidocSignatureSpan">hprose.</span>JSONRPCClientFilter
        <span class="apidocSignatureSpan">(version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONRPCClientFilter(version) {
    this.version = version || &#x27;2.0&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.JSONRPCServiceFilter" id="apidoc.element.hprose.JSONRPCServiceFilter">
        function <span class="apidocSignatureSpan">hprose.</span>JSONRPCServiceFilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONRPCServiceFilter() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.RawReader" id="apidoc.element.hprose.RawReader">
        function <span class="apidocSignatureSpan">hprose.</span>RawReader
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RawReader(stream) {
    Object.defineProperties(this, {
        stream: { value : stream },
        readRaw: { value: function() { return readRaw(stream); } }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Reader" id="apidoc.element.hprose.Reader">
        function <span class="apidocSignatureSpan">hprose.</span>Reader
        <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(stream, simple, useHarmonyMap) {
    RawReader.call(this, stream);
    this.useHarmonyMap = !!useHarmonyMap;
    Object.defineProperties(this, {
        classref: { value: [] },
        refer: { value: simple ? fakeReaderRefer : realReaderRefer() }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Server" id="apidoc.element.hprose.Server">
        function <span class="apidocSignatureSpan">hprose.</span>Server
        <span class="apidocSignatureSpan">(uri, tlsOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(uri, tlsOptions, handler) {
    return create(uri, tlsOptions, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    catch(e) {}
}

httpserver.on(&#x27;clientError&#x27;, onerror);

function start() {
    httpserver.listen(port, host);
    server = new ws.<span class="apidocCodeKeywordSpan">Server</span>(options);
    server.on(&#x27;connection&#x27;, self.wsHandle);
    server.on(&#x27;error&#x27;, onerror);
}
function stop() {
    server.close();
    httpserver.close();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Service" id="apidoc.element.hprose.Service">
        function <span class="apidocSignatureSpan">hprose.</span>Service
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service() {
    EventEmitter.call(this);

    var _calls                  = {},
        _names                  = [],
        _filters                = [],
        _onBeforeInvoke         = null,
        _onAfterInvoke          = null,
        _onSendError            = null,
        _timeout                = 120000,
        _heartbeat              = 3000,
        _errorDelay             = 10000,
        _simple                 = false,
        _debug                  = false,
        _passContext            = false,
        _topics                 = {},
        _events                 = {},
        _invokeHandler          = invokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],

        self = this;

    function inputFilter(data, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            data = _filters[i].inputFilter(data, context);
        }
        return data;
    }

    function outputFilter(data, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            data = _filters[i].outputFilter(data, context);
        }
        return data;
    }

    function getBeforeInvoke() {
        return _onBeforeInvoke;
    }

    function setBeforeInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onBeforeInvoke = value;
        }
        else {
            throw new Error(&#x27;onBeforeInvoke must be a function or null.&#x27;);
        }
    }

    function getAfterInvoke() {
        return _onAfterInvoke;
    }

    function setAfterInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAfterInvoke = value;
        }
        else {
            throw new Error(&#x27;onAfterInvoke must be a function or null.&#x27;);
        }
    }

    function getSendError() {
        return _onSendError;
    }

    function setSendError(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendError = value;
        }
        else {
            throw new Error(&#x27;onSendError must be a function or null.&#x27;);
        }
    }

    function sendError(error, context) {
        if (!isError(error)) {
            error = new Error(error);
        }
        try {
            self.emit(&#x27;sendError&#x27;, error, context);
            if (_onSendError !== null) {
                var e = _onSendError(error, context);
                if (isError(e)) {
                    error = e;
                }
            }
        }
        catch(e) {
            error = e;
        }
        var stream = new BytesIO();
        var writer = new Writer(stream, true);
        stream.writeByte(Tags.TagError);
        writer.writeString(_debug ? error.stack : error.message);
        return stream;
    }

    function endError(error, context) {
        var stream = sendError(error, context);
        stream.writeByte(Tags.TagEnd);
        return stream.bytes;
    }

    function beforeInvoke(name, args, context) {
        try {
            self.emit(&#x27;beforeInvoke&#x27;, name, args, context.byref, context);
            if (_onBeforeInvoke !== null) {
                var value = _onBeforeInvoke(name, args, context.byref, context);
                if (isError(value)) { throw value; }
                if (Future.isPromise(value)) {
                    return value.then(function(e) {
                        if (isError(e)) { throw e; }
                        return invoke(name, args, context);
                    }).then(null, function(e) {
                        return sendError(e, context);
                    });
                }
            }
            return invoke(name, args, context).then(null, function(e) {
                return sendError(e, context);
            });
        }
        catch (e) {
            return sendError(e, context);
        }
    }

    function invokeHandler(name, args, context) {
        if ((&#x27;*&#x27; in _calls) &#x26;&#x26; (context.method === _calls[&#x27;*&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.SocketClient" id="apidoc.element.hprose.SocketClient">
        function <span class="apidocSignatureSpan">hprose.</span>SocketClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketClient(uri, functions, settings) {
    if (this.constructor !== SocketClient) {
        return new SocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var self = this;
    var _noDelay = true;
    var _fullDuplex = false;
    var _maxPoolSize = 10;
    var _poolTimeout = 30000;
    var fdtrans = null;
    var hdtrans = null;

    function getNoDelay() {
        return _noDelay;
    }

    function setNoDelay(value) {
        _noDelay = !!value;
    }

    function getFullDuplex() {
        return _fullDuplex;
    }

    function setFullDuplex(value) {
        _fullDuplex = !!value;
    }

    function getMaxPoolSize() {
        return _maxPoolSize;
    }

    function setMaxPoolSize(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _maxPoolSize = value | 0;
            if (_maxPoolSize &#x3c; 1) {
                _maxPoolSize = 10;
            }
        }
        else {
            _maxPoolSize = 10;
        }
    }

    function getPoolTimeout() {
        return _poolTimeout;
    }

    function setPoolTimeout(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _poolTimeout = value | 0;
        }
        else {
            _poolTimeout = 0;
        }
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        if (_fullDuplex) {
            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {
                fdtrans = new FullDuplexSocketTransporter(self);
            }
            fdtrans.sendAndReceive(request, future, context);
        }
        else {
            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {
                hdtrans = new HalfDuplexSocketTransporter(self);
            }
            hdtrans.sendAndReceive(request, future, context);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    Object.defineProperties(this, {
        noDelay: { get: getNoDelay, set: setNoDelay },
        fullDuplex: { get: getFullDuplex, set: setFullDuplex },
        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },
        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.SocketServer" id="apidoc.element.hprose.SocketServer">
        function <span class="apidocSignatureSpan">hprose.</span>SocketServer
        <span class="apidocSignatureSpan">(options, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketServer(options, tlsOptions) {
    SocketService.call(this);
    var self = this;
    var server = (tlsOptions ?
        tls.createServer(tlsOptions, self.handle) :
        net.createServer(self.handle));

    server.on(&#x27;error&#x27;, function (e) {
        var context = { server: server, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(options);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.SocketService" id="apidoc.element.hprose.SocketService">
        function <span class="apidocSignatureSpan">hprose.</span>SocketService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketService() {
    Service.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(socket, data, id) {
        var p = (id === null ? 4 : 8);
        var n = data.length;
        var buf = new Buffer(p + n);
        if (p === 8) {
            buf.writeInt32BE(n | 0x80000000, 0);
            buf.writeInt32BE(id, 4);
        }
        else {
            buf.writeUInt32BE(n, 0);
        }
        for (var i = 0; i &#x3c; n; i++) {
            buf[i + p] = data[i];
        }
        socket.write(buf);
    }

    function send(socket, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(socket, data, id); });
        }
        else {
            _send(socket, data, id);
        }
    }

    function run(socket, data, id) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        data = self.defaultHandle(data, context);
        send(socket, data, id);
    }

    function receive(socket) {
        var bytes = new BytesIO();
        var headerLength = 4;
        var dataLength = -1;
        var id = null;
        socket.on(&#x27;data&#x27;, function(chunk) {
            bytes.write(chunk);
            while (true) {
                if ((dataLength &#x3c; 0) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    dataLength = bytes.readInt32BE();
                    if ((dataLength &#x26; 0x80000000) !== 0) {
                        dataLength &#x26;= 0x7fffffff;
                        headerLength = 8;
                    }
                }
                if ((headerLength === 8) &#x26;&#x26; (id === null) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    id = bytes.readInt32BE();
                }
                if ((dataLength &#x3e;= 0) &#x26;&#x26; ((bytes.length - headerLength) &#x3e;= dataLength)) {
                    var data = bytes.read(dataLength);
                    run(socket, data, id);
                    bytes.trunc();
                    dataLength = -1;
                    headerLength = 4;
                    id = null;
                }
                else {
                    break;
                }
            }
        });
    }

    function handle(socket) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            socket.end();
            return;
        }
        socket.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;, context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        socket.on(&#x27;end&#x27;, noop);
        socket.on(&#x27;error&#x27;, function(e) {
            try {
                if (e.code != &#x22;EPIPE&#x22;) {
                    self.emit(&#x27;sendError&#x27;, e, context);
                    if (self.onSendError) {
                        self.onSendError(e, context);
                    }
                }
            }
            catch(e) {}
        });
        socket.setTimeout(self.timeout);
        receive(socket);
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        handle: { value: handle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.TcpClient" id="apidoc.element.hprose.TcpClient">
        function <span class="apidocSignatureSpan">hprose.</span>TcpClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketClient(uri, functions, settings) {
    if (this.constructor !== SocketClient) {
        return new SocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var self = this;
    var _noDelay = true;
    var _fullDuplex = false;
    var _maxPoolSize = 10;
    var _poolTimeout = 30000;
    var fdtrans = null;
    var hdtrans = null;

    function getNoDelay() {
        return _noDelay;
    }

    function setNoDelay(value) {
        _noDelay = !!value;
    }

    function getFullDuplex() {
        return _fullDuplex;
    }

    function setFullDuplex(value) {
        _fullDuplex = !!value;
    }

    function getMaxPoolSize() {
        return _maxPoolSize;
    }

    function setMaxPoolSize(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _maxPoolSize = value | 0;
            if (_maxPoolSize &#x3c; 1) {
                _maxPoolSize = 10;
            }
        }
        else {
            _maxPoolSize = 10;
        }
    }

    function getPoolTimeout() {
        return _poolTimeout;
    }

    function setPoolTimeout(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _poolTimeout = value | 0;
        }
        else {
            _poolTimeout = 0;
        }
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        if (_fullDuplex) {
            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {
                fdtrans = new FullDuplexSocketTransporter(self);
            }
            fdtrans.sendAndReceive(request, future, context);
        }
        else {
            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {
                hdtrans = new HalfDuplexSocketTransporter(self);
            }
            hdtrans.sendAndReceive(request, future, context);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    Object.defineProperties(this, {
        noDelay: { get: getNoDelay, set: setNoDelay },
        fullDuplex: { get: getFullDuplex, set: setFullDuplex },
        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },
        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.TcpServer" id="apidoc.element.hprose.TcpServer">
        function <span class="apidocSignatureSpan">hprose.</span>TcpServer
        <span class="apidocSignatureSpan">(options, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketServer(options, tlsOptions) {
    SocketService.call(this);
    var self = this;
    var server = (tlsOptions ?
        tls.createServer(tlsOptions, self.handle) :
        net.createServer(self.handle));

    server.on(&#x27;error&#x27;, function (e) {
        var context = { server: server, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(options);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.TimeoutError" id="apidoc.element.hprose.TimeoutError">
        function <span class="apidocSignatureSpan">hprose.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
    Error.call(this);
    this.message = message;
    this.name = TimeoutError.name;
    if (typeof Error.captureStackTrace === &#x27;function&#x27;) {
        Error.captureStackTrace(this, TimeoutError);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.UnixClient" id="apidoc.element.hprose.UnixClient">
        function <span class="apidocSignatureSpan">hprose.</span>UnixClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketClient(uri, functions, settings) {
    if (this.constructor !== SocketClient) {
        return new SocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var self = this;
    var _noDelay = true;
    var _fullDuplex = false;
    var _maxPoolSize = 10;
    var _poolTimeout = 30000;
    var fdtrans = null;
    var hdtrans = null;

    function getNoDelay() {
        return _noDelay;
    }

    function setNoDelay(value) {
        _noDelay = !!value;
    }

    function getFullDuplex() {
        return _fullDuplex;
    }

    function setFullDuplex(value) {
        _fullDuplex = !!value;
    }

    function getMaxPoolSize() {
        return _maxPoolSize;
    }

    function setMaxPoolSize(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _maxPoolSize = value | 0;
            if (_maxPoolSize &#x3c; 1) {
                _maxPoolSize = 10;
            }
        }
        else {
            _maxPoolSize = 10;
        }
    }

    function getPoolTimeout() {
        return _poolTimeout;
    }

    function setPoolTimeout(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _poolTimeout = value | 0;
        }
        else {
            _poolTimeout = 0;
        }
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        if (_fullDuplex) {
            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {
                fdtrans = new FullDuplexSocketTransporter(self);
            }
            fdtrans.sendAndReceive(request, future, context);
        }
        else {
            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {
                hdtrans = new HalfDuplexSocketTransporter(self);
            }
            hdtrans.sendAndReceive(request, future, context);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    Object.defineProperties(this, {
        noDelay: { get: getNoDelay, set: setNoDelay },
        fullDuplex: { get: getFullDuplex, set: setFullDuplex },
        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },
        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.UnixServer" id="apidoc.element.hprose.UnixServer">
        function <span class="apidocSignatureSpan">hprose.</span>UnixServer
        <span class="apidocSignatureSpan">(options, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketServer(options, tlsOptions) {
    SocketService.call(this);
    var self = this;
    var server = (tlsOptions ?
        tls.createServer(tlsOptions, self.handle) :
        net.createServer(self.handle));

    server.on(&#x27;error&#x27;, function (e) {
        var context = { server: server, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(options);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.WebSocketClient" id="apidoc.element.hprose.WebSocketClient">
        function <span class="apidocSignatureSpan">hprose.</span>WebSocketClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketClient(uri, functions, settings) {
    if (this.constructor !== WebSocketClient) {
        return new WebSocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var _id = 0;
    var _count = 0;
    var _futures = [];
    var _requests = [];
    var _ready = null;
    var ws = null;

    var self = this;

    function getNextId() {
        return (_id &#x3c; 0x7fffffff) ? ++_id : _id = 0;
    }

    function send(id, request) {
        var bytes = new BytesIO();
        bytes.writeInt32BE(id);
        if (request.constructor === String) {
            bytes.writeString(request);
        }
        else {
            bytes.write(request);
        }
        var future = _futures[id];
        try {
            ws.send(bytes.bytes);
        }
        catch (e) {
            future.reject(e);
        }
    }
    function onopen() {
        _ready.resolve();
    }
    function onmessage(data) {
        var bytes = new BytesIO(data);
        var id = bytes.readInt32BE();
        var future = _futures[id];
        delete _futures[id];
        if (future !== undefined) {
            --_count;
            future.resolve(bytes.read(bytes.length - 4));
        }
        if ((_count &#x3c; 100) &#x26;&#x26; (_requests.length &#x3e; 0)) {
            ++_count;
            var request = _requests.pop();
            _ready.then(function() { send(request[0], request[1]); });
        }
        if (_count === 0) {
            if (!self.keepAlive) { close(); }
        }
    }
    function onclose(code, message) {
        onerror(new Error(code + &#x27;:&#x27; + message));
        ws = null;
    }
    function onerror(error) {
        _futures.forEach(function(future, id) {
            future.reject(error);
            delete _futures[id];
        });
        _count = 0;
    }
    function connect() {
        _ready = new Future();
        self.setOption(&#x27;perMessageDeflate&#x27;, false);
        ws = new WebSocket(self.uri, self.options);
        ws.on(&#x27;open&#x27;, onopen);
        ws.on(&#x27;message&#x27;, onmessage);
        ws.on(&#x27;error&#x27;, onerror);
        ws.on(&#x27;close&#x27;, onclose);
    }
    function sendAndReceive(request, context) {
        var id = getNextId();
        var future = new Future();
        _futures[id] = future;
        if (context.timeout &#x3e; 0) {
            future = future.timeout(context.timeout).catchError(function(e) {
                delete _futures[id];
                --_count;
                throw e;
            },
            function(e) {
                return e instanceof TimeoutError;
            });
        }
        if (ws === null ||
            ws.readyState === WebSocket.CLOSING ||
            ws.readyState === WebSocket.CLOSED) {
            connect();
        }
        if (_count &#x3c; 100) {
            ++_count;
            _ready.then(function() { send(id, request); });
        }
        else {
            _requests.push([id, request]);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }
    function close() {
        if (ws !== null) {
            ws.removeAllListeners(&#x27;open&#x27;);
            ws.removeAllListeners(&#x27;message&#x27;);
            ws.removeAllListeners(&#x27;error&#x27;);
            ws.removeAllListeners(&#x27;close&#x27;);
            ws.close();
        }
    }
    Object.defineProperties(this, {
        sendAndReceive: { value: sendAndReceive },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.WebSocketServer" id="apidoc.element.hprose.WebSocketServer">
        function <span class="apidocSignatureSpan">hprose.</span>WebSocketServer
        <span class="apidocSignatureSpan">(options, tlsOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, tlsOptions, handler) {
    WebSocketService.call(this);
    var self = this;
    if (!handler) handler = this.handle;
    var httpserver = tlsOptions ?
        https.createServer(tlsOptions, handler) :
        http.createServer(handler);
    var host = options.host;
    var port = options.port;
    delete options.host;
    delete options.port;
    options.server = httpserver;
    options.perMessageDeflate = false;
    var server = null;

    function onerror(e, socket) {
        var context = {
            httpserver: httpserver,
            server: self.server,
            userdata:{}
        };
        if (socket) { context.socket = socket; }
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    }

    httpserver.on(&#x27;clientError&#x27;, onerror);

    function start() {
        httpserver.listen(port, host);
        server = new ws.Server(options);
        server.on(&#x27;connection&#x27;, self.wsHandle);
        server.on(&#x27;error&#x27;, onerror);
    }
    function stop() {
        server.close();
        httpserver.close();
    }
    function listen() {
        httpserver.listen.apply(httpserver, arguments);
        server = new ws.Server(options);
        server.on(&#x27;connection&#x27;, self.wsHandle);
        server.on(&#x27;error&#x27;, onerror);
    }
    function close(callback) {
        server.close();
        httpserver.close(callback);
    }

    Object.defineProperties(this, {
        httpserver: { get: function () { return httpserver; } },
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.WebSocketService" id="apidoc.element.hprose.WebSocketService">
        function <span class="apidocSignatureSpan">hprose.</span>WebSocketService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketService() {
    HttpService.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(ws, data, id) {
        var bytes = new BytesIO();
        bytes.writeInt32BE(id);
        if (data.constructor === String) {
            bytes.writeString(data);
        }
        else {
            bytes.write(data);
        }
        try {
            ws.send(bytes.bytes, {
                binary: true,
                compress: false
            });
        }
        catch (e) {
            ws.emit(&#x27;error&#x27;, e);
        }
    }

    function send(ws, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(ws, data, id); });
        }
        else {
            _send(ws, data, id);
        }
    }

    function wsHandle(ws) {
        var context = {
            httpserver: self.httpserver,
            server: self.server,
            websocket: ws,
            socket: ws._socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            ws.close();
            return;
        }
        ws.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;,context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        ws.on(&#x27;error&#x27;, function(e) {
            try {
                self.emit(&#x27;sendError&#x27;, e, context);
                if (self.onSendError) {
                    self.onSendError(e, context);
                }
            }
            catch(e) {}
        });
        ws.on(&#x27;message&#x27;, function(data) {
            var bytes = new BytesIO(data);
            var id = bytes.readInt32BE();
            var request = bytes.read(bytes.length - 4);
            process.nextTick(function() {
                var context = {
                    httpserver: self.httpserver,
                    server: self.server,
                    websocket: ws,
                    socket: ws._socket,
                    userdata: {}
                };
                data = self.defaultHandle(request, context);
                send(ws, data, id);
            });
        });
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        wsHandle: { value: wsHandle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Writer" id="apidoc.element.hprose.Writer">
        function <span class="apidocSignatureSpan">hprose.</span>Writer
        <span class="apidocSignatureSpan">(stream, simple)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(stream, simple) {
    Object.defineProperties(this, {
        stream: { value: stream },
        _classref: { value: Object.create(null), writable: true },
        _fieldsref: { value: [], writable: true },
        _refer: { value: simple ? fakeWriterRefer : realWriterRefer(stream) }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.co" id="apidoc.element.hprose.co">
        function <span class="apidocSignatureSpan">hprose.</span>co
        <span class="apidocSignatureSpan">(gen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function co(gen) {
    var thisArg = (function() { return this; })();
    if (typeof gen === &#x27;function&#x27;) {
        var args = slice.call(arguments, 1);
        gen = gen.apply(thisArg, args);
    }

    if (!gen || typeof gen.next !== &#x27;function&#x27;) {
        return toFuture(gen);
    }

    var future = new Future();

    function onFulfilled(res) {
        try {
            next(gen.next(res));
        }
        catch (e) {
            future.reject(e);
        }
    }

    function onRejected(err) {
        try {
            next(gen[&#x27;throw&#x27;](err));
        }
        catch (e) {
            future.reject(e);
        }
    }

    function next(ret) {
        if (ret.done) {
            future.resolve(ret.value);
        }
        else {
            ((&#x27;function&#x27; == typeof ret.value) ?
            thunkToPromise(ret.value) :
            toPromise(ret.value)).then(onFulfilled, onRejected);
        }
    }

    onFulfilled();

    return future;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.deferred" id="apidoc.element.hprose.deferred">
        function <span class="apidocSignatureSpan">hprose.</span>deferred
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferred = function () {
    var self = new Future();
    return Object.create(null, {
        promise: { value: self },
        resolve: { value: self.resolve },
        reject: { value: self.reject }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.generic" id="apidoc.element.hprose.generic">
        function <span class="apidocSignatureSpan">hprose.</span>generic
        <span class="apidocSignatureSpan">(method)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function generic(method) {
    if (typeof method !== &#x22;function&#x22;) {
        throw new TypeError(method + &#x22; is not a function&#x22;);
    }
    return function(context) {
        return method.apply(context, Array.prototype.slice.call(arguments, 1));
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.isObjectEmpty" id="apidoc.element.hprose.isObjectEmpty">
        function <span class="apidocSignatureSpan">hprose.</span>isObjectEmpty
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObjectEmpty = function (obj) {
    if (obj) {
        var prop;
        for (prop in obj) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.promisify" id="apidoc.element.hprose.promisify">
        function <span class="apidocSignatureSpan">hprose.</span>promisify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function promisify(fn) {
    return function() {
        var args = slice.call(arguments, 0);
        var future = new Future();
        args.push(getThunkCallback(future));
        try {
            fn.apply(this, args);
        }
        catch (err) {
            future.reject(err);
        }
        return future;
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.register" id="apidoc.element.hprose.register">
        function <span class="apidocSignatureSpan">hprose.</span>register
        <span class="apidocSignatureSpan">(cls, alias)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function register(cls, alias) {
    aliasCache.set(cls, alias);
    classCache[alias] = cls;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}
}
function getClass(classname) {
var cls = ClassManager.getClass(classname);
if (cls) { return cls; }
cls = getter(classname);
if (typeof(cls) === &#x27;function&#x27;) {
    ClassManager.<span class="apidocCodeKeywordSpan">register</span>(cls, classname);
    return cls;
}
var poslist = [];
var pos = classname.indexOf(&#x27;_&#x27;);
while (pos &#x3e;= 0) {
    poslist[poslist.length] = pos;
    pos = classname.indexOf(&#x27;_&#x27;, pos + 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.rejected" id="apidoc.element.hprose.rejected">
        function <span class="apidocSignatureSpan">hprose.</span>rejected
        <span class="apidocSignatureSpan">(e)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function error(e) {
    var future = new Future();
    future.reject(e);
    return future;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.resolved" id="apidoc.element.hprose.resolved">
        function <span class="apidocSignatureSpan">hprose.</span>resolved
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function value(v) {
    var future = new Future();
    future.resolve(v);
    return future;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.serialize" id="apidoc.element.hprose.serialize">
        function <span class="apidocSignatureSpan">hprose.</span>serialize
        <span class="apidocSignatureSpan">(value, simple)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function serialize(value, simple) {
    var stream = new BytesIO();
    var writer = new Writer(stream, simple);
    writer.serialize(value);
    return stream;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var response = responses[i];
        if (response.error) {
            stream.writeByte(Tags.TagError);
            writer.writeString(response.error.message);
        }
        else {
            stream.writeByte(Tags.TagResult);
            writer.<span class="apidocCodeKeywordSpan">serialize</span>(response.result);
        }
    }
    stream.writeByte(Tags.TagEnd);
    return stream.bytes;
};

JSONRPCClientFilter.prototype.outputFilter = function outputFilter(data/*, context*/) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.thunkify" id="apidoc.element.hprose.thunkify">
        function <span class="apidocSignatureSpan">hprose.</span>thunkify
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function thunkify(fn) {
    return function() {
        var args = slice.call(arguments, 0);
        var thisArg = this;
        var results = new Future();
        args.push(function() {
            thisArg = this;
            results.resolve(arguments);
        });
        try {
            fn.apply(this, args);
        }
        catch (err) {
            results.resolve([err]);
        }
        return function(done) {
            results.then(function(results) {
                done.apply(thisArg, results);
            });
        };
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.toArray" id="apidoc.element.hprose.toArray">
        function <span class="apidocSignatureSpan">hprose.</span>toArray
        <span class="apidocSignatureSpan">(arrayLikeObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toArray(arrayLikeObject) {
    var n = arrayLikeObject.length;
    var a = new Array(n);
    for (var i = 0; i &#x3c; n; ++i) {
        a[i] = arrayLikeObject[i];
    }
    return a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.toBinaryString" id="apidoc.element.hprose.toBinaryString">
        function <span class="apidocSignatureSpan">hprose.</span>toBinaryString
        <span class="apidocSignatureSpan">(bytes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toBinaryString(bytes) {
    if (bytes instanceof ArrayBuffer) {
        bytes = new Uint8Array(bytes);
    }
    var n = bytes.length;
    if (n &#x3c; 0xFFFF) {
        return String.fromCharCode.apply(String, getCharCodes(bytes));
    }
    var remain = n &#x26; 0x7FFF;
    var count = n &#x3e;&#x3e; 15;
    var a = new Array(remain ? count + 1 : count);
    for (var i = 0; i &#x3c; count; ++i) {
        a[i] = String.fromCharCode.apply(String, getCharCodes(bytes.subarray(i &#x3c;&#x3c; 15, (i + 1) &#x3c;&#x3c; 15)));
    }
    if (remain) {
        a[count] = String.fromCharCode.apply(String, getCharCodes(bytes.subarray(count &#x3c;&#x3c; 15, n)));
    }
    return a.join(&#x27;&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.toUint8Array" id="apidoc.element.hprose.toUint8Array">
        function <span class="apidocSignatureSpan">hprose.</span>toUint8Array
        <span class="apidocSignatureSpan">(bs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toUint8Array(bs) {
    var n = bs.length;
    var data = new Uint8Array(n);
    for (var i = 0; i &#x3c; n; i++) {
        data[i] = bs.charCodeAt(i) &#x26; 0xFF;
    }
    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.unserialize" id="apidoc.element.hprose.unserialize">
        function <span class="apidocSignatureSpan">hprose.</span>unserialize
        <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unserialize(stream, simple, useHarmonyMap) {
    if (!(stream instanceof BytesIO)) {
        stream = new BytesIO(stream);
    }
    return new Reader(stream, simple, useHarmonyMap).unserialize();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var reader = new Reader(stream, false, context.useHarmonyMap);
var tag = stream.readByte();
if (tag === Tags.TagResult) {
    if (context.mode === ResultMode.Serialized) {
        result = reader.readRaw();
    }
    else {
        result = reader.<span class="apidocCodeKeywordSpan">unserialize</span>();
    }
    tag = stream.readByte();
    if (tag === Tags.TagArgument) {
        reader.reset();
        var _args = reader.readList();
        copyargs(_args, args);
        tag = stream.readByte();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.wrap" id="apidoc.element.hprose.wrap">
        function <span class="apidocSignatureSpan">hprose.</span>wrap
        <span class="apidocSignatureSpan">(handler, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(handler, thisArg) {
    return function() {
        thisArg = thisArg || this;
        return all(arguments).then(function(args) {
            var result = handler.apply(thisArg, args);
            if (isGeneratorFunction(result) || isGenerator(result)) {
                return co.call(thisArg, result);
            }
            return result;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.Client" id="apidoc.module.hprose.Client">module hprose.Client</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.Client.Client" id="apidoc.element.hprose.Client.Client">
        function <span class="apidocSignatureSpan">hprose.</span>Client
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(uri, functions, settings) {
    EventEmitter.call(this);
    this.on(&#x27;error&#x27;, noop);

    // private members
    var _uri,
        _uriList                = [],
        _index                  = -1,
        _byref                  = false,
        _simple                 = false,
        _timeout                = 30000,
        _retry                  = 10,
        _idempotent             = false,
        _failswitch             = false,
        _failround              = 0,
        _lock                   = false,
        _tasks                  = [],
        _useHarmonyMap          = false,
        _onerror                = noop,
        _onfailswitch           = noop,
        _filters                = [],
        _batch                  = false,
        _batches                = [],
        _ready                  = new Future(),
        _topics                 = Object.create(null),
        _id                     = null,
        _keepAlive              = true,
        _invokeHandler          = invokeHandler,
        _batchInvokeHandler     = batchInvokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _batchInvokeHandlers    = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],
        _options                = Object.create(null),

        self = this;

    function outputFilter(request, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            request = _filters[i].outputFilter(request, context);
        }
        return request;
    }

    function inputFilter(response, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            response = _filters[i].inputFilter(response, context);
        }
        return response;
    }

    function beforeFilterHandler(request, context) {
        request = outputFilter(request, context);
        return _afterFilterHandler(request, context)
        .then(function(response) {
            if (context.oneway) { return; }
            return inputFilter(response, context);
        });
    }

    function afterFilterHandler(request, context) {
         return self.sendAndReceive(request, context).catchError(function(e) {
             var response = retry(request, context);
             if (response !== null) {
                 return response;
             }
             throw e;
        });
    }

    function sendAndReceive(request, context, onsuccess, onerror) {
        _beforeFilterHandler(request, context).then(onsuccess, onerror);
    }

    function failswitch() {
        var n = _uriList.length;
        if (n &#x3e; 1) {
            var i = _index + 1;
            if (i &#x3e;= n) {
                i = 0;
                _failround++;
            }
            _index = i;
            _uri = _uriList[_index];
        }
        else {
            _failround++;
        }
        _onfailswitch(self);
        self.emit(&#x27;failswitch&#x27;, self);
    }

    function retry(data, context) {
        if (context.failswitch) {
            failswitch();
        }
        if (context.idempotent &#x26;&#x26; (context.retried &#x3c; context.retry)) {
            var interval = ++context.retried * 500;
            if (context.failswitch) {
                interval -= (_uriList.length - 1) * 500;
            }
            if (interval &#x3e; 5000) {
                interval = 5000;
            }
            if (interval &#x3e; 0) {
                return Future.delayed(interval, function() {
                    return afterFilterHandler(data, context);
                });
            }
            else {
                return afterFilterHandler(data, context);
            }
        }
        return null;
    }

    function initService(stub) {
        var context = {
            retry: _retry,
            retried: 0,
            idempotent: true,
            failswitch: true,
            timeout: _timeout,
            client: self,
            userdata: {}
        };
        var onsuccess = function(data) {
            var error = nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Client.super_" id="apidoc.element.hprose.Client.super_">
        function <span class="apidocSignatureSpan">hprose.Client.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.Formatter" id="apidoc.module.hprose.Formatter">module hprose.Formatter</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.Formatter.serialize" id="apidoc.element.hprose.Formatter.serialize">
        function <span class="apidocSignatureSpan">hprose.Formatter.</span>serialize
        <span class="apidocSignatureSpan">(value, simple)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">serialize = function (value, simple) {
    return serialize(value, simple).bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var response = responses[i];
        if (response.error) {
            stream.writeByte(Tags.TagError);
            writer.writeString(response.error.message);
        }
        else {
            stream.writeByte(Tags.TagResult);
            writer.<span class="apidocCodeKeywordSpan">serialize</span>(response.result);
        }
    }
    stream.writeByte(Tags.TagEnd);
    return stream.bytes;
};

JSONRPCClientFilter.prototype.outputFilter = function outputFilter(data/*, context*/) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Formatter.unserialize" id="apidoc.element.hprose.Formatter.unserialize">
        function <span class="apidocSignatureSpan">hprose.Formatter.</span>unserialize
        <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unserialize(stream, simple, useHarmonyMap) {
    if (!(stream instanceof BytesIO)) {
        stream = new BytesIO(stream);
    }
    return new Reader(stream, simple, useHarmonyMap).unserialize();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var reader = new Reader(stream, false, context.useHarmonyMap);
var tag = stream.readByte();
if (tag === Tags.TagResult) {
    if (context.mode === ResultMode.Serialized) {
        result = reader.readRaw();
    }
    else {
        result = reader.<span class="apidocCodeKeywordSpan">unserialize</span>();
    }
    tag = stream.readByte();
    if (tag === Tags.TagArgument) {
        reader.reset();
        var _args = reader.readList();
        copyargs(_args, args);
        tag = stream.readByte();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.HttpClient" id="apidoc.module.hprose.HttpClient">module hprose.HttpClient</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.HttpClient.HttpClient" id="apidoc.element.hprose.HttpClient.HttpClient">
        function <span class="apidocSignatureSpan">hprose.</span>HttpClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpClient(uri, functions, settings) {
    if (this.constructor !== HttpClient) {
        return new HttpClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);
    var _header = Object.create(null);

    var self = this;

    function getRequestHeader(headers) {
        var header = Object.create(null);
        var name, value;
        for (name in _header) {
            header[name] = _header[name];
        }
        if (headers) {
            for (name in headers) {
                value = headers[name];
                if (Array.isArray(value)) {
                    header[name] = value.join(&#x27;, &#x27;);
                }
                else {
                    header[name] = value;
                }
            }
        }
        return header;
    }

    function send(request, future, context) {
        request = BytesIO.toBuffer(request);
        var options = parse(self.uri);
        var protocol = options.protocol;
        var client;
        var secure;
        if (protocol === &#x27;http:&#x27;) {
            client = http;
            secure = false;
        }
        else if (protocol === &#x27;https:&#x27;) {
            client = https;
            secure = true;
        }
        else {
            throw new Error(&#x27;Unsupported &#x27; + protocol + &#x27; protocol!&#x27;);
        }
        options.keepAlive = self.keepAlive;
        for (var key in self.options) {
            options[key] = self.options[key];
        }
        options.method = &#x27;POST&#x27;;
        options.headers = getRequestHeader(context.httpHeader);
        options.headers[&#x27;Content-Length&#x27;] = request.length;
        var cookie = getCookie(options.host, options.path, secure);
        if (cookie !== &#x27;&#x27;) {
            options.headers.Cookie = cookie;
        }
        var req = client.request(options, function(resp) {
            context.httpHeader = resp.headers;
            var bytes = new BytesIO();
            resp.on(&#x27;data&#x27;, function(data) { bytes.write(data); });
            resp.on(&#x27;end&#x27;, function() {
                if (resp.statusCode === 200) {
                    future.resolve(bytes.bytes);
                }
                else {
                    future.reject(new Error(resp.statusCode + &#x27;:&#x27; + bytes.toString()));
                }
            });
            resp.on(&#x27;error&#x27;, future.reject);
            if (resp.statusCode === 200) {
                setCookie(resp.headers, options.host);
            }
        });
        req.on(&#x27;error&#x27;, future.reject);
        req.end(request);
        return req;
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        var req = send(request, future, context);
        if (context.timeout &#x3e; 0) {
            future = future.timeout(context.timeout).catchError(function(e) {
                req.removeAllListeners(&#x27;error&#x27;);
                req.on(&#x27;error&#x27;, noop);
                req.abort();
                throw e;
            },
            function(e) {
                return e instanceof TimeoutError;
            });
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    function setHeader(name, value) {
        if (name.toLowerCase() !== &#x27;content-type&#x27; &#x26;&#x26;
            name.toLowerCase() !== &#x27;content-length&#x27; &#x26;&#x26;
            name.toLowerCase() !== &#x27;host&#x27;) {
            if (value) {
                _header[name] = value;
            }
            else {
                delete _header[name];
            }
        }
    }

    Object.defineProperties(this, {
        setHeader: { value: setHeader },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.HttpClient.super_" id="apidoc.element.hprose.HttpClient.super_">
        function <span class="apidocSignatureSpan">hprose.HttpClient.</span>super_
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(uri, functions, settings) {
    EventEmitter.call(this);
    this.on(&#x27;error&#x27;, noop);

    // private members
    var _uri,
        _uriList                = [],
        _index                  = -1,
        _byref                  = false,
        _simple                 = false,
        _timeout                = 30000,
        _retry                  = 10,
        _idempotent             = false,
        _failswitch             = false,
        _failround              = 0,
        _lock                   = false,
        _tasks                  = [],
        _useHarmonyMap          = false,
        _onerror                = noop,
        _onfailswitch           = noop,
        _filters                = [],
        _batch                  = false,
        _batches                = [],
        _ready                  = new Future(),
        _topics                 = Object.create(null),
        _id                     = null,
        _keepAlive              = true,
        _invokeHandler          = invokeHandler,
        _batchInvokeHandler     = batchInvokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _batchInvokeHandlers    = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],
        _options                = Object.create(null),

        self = this;

    function outputFilter(request, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            request = _filters[i].outputFilter(request, context);
        }
        return request;
    }

    function inputFilter(response, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            response = _filters[i].inputFilter(response, context);
        }
        return response;
    }

    function beforeFilterHandler(request, context) {
        request = outputFilter(request, context);
        return _afterFilterHandler(request, context)
        .then(function(response) {
            if (context.oneway) { return; }
            return inputFilter(response, context);
        });
    }

    function afterFilterHandler(request, context) {
         return self.sendAndReceive(request, context).catchError(function(e) {
             var response = retry(request, context);
             if (response !== null) {
                 return response;
             }
             throw e;
        });
    }

    function sendAndReceive(request, context, onsuccess, onerror) {
        _beforeFilterHandler(request, context).then(onsuccess, onerror);
    }

    function failswitch() {
        var n = _uriList.length;
        if (n &#x3e; 1) {
            var i = _index + 1;
            if (i &#x3e;= n) {
                i = 0;
                _failround++;
            }
            _index = i;
            _uri = _uriList[_index];
        }
        else {
            _failround++;
        }
        _onfailswitch(self);
        self.emit(&#x27;failswitch&#x27;, self);
    }

    function retry(data, context) {
        if (context.failswitch) {
            failswitch();
        }
        if (context.idempotent &#x26;&#x26; (context.retried &#x3c; context.retry)) {
            var interval = ++context.retried * 500;
            if (context.failswitch) {
                interval -= (_uriList.length - 1) * 500;
            }
            if (interval &#x3e; 5000) {
                interval = 5000;
            }
            if (interval &#x3e; 0) {
                return Future.delayed(interval, function() {
                    return afterFilterHandler(data, context);
                });
            }
            else {
                return afterFilterHandler(data, context);
            }
        }
        return null;
    }

    function initService(stub) {
        var context = {
            retry: _retry,
            retried: 0,
            idempotent: true,
            failswitch: true,
            timeout: _timeout,
            client: self,
            userdata: {}
        };
        var onsuccess = function(data) {
            var error = nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.HttpServer" id="apidoc.module.hprose.HttpServer">module hprose.HttpServer</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.HttpServer.HttpServer" id="apidoc.element.hprose.HttpServer.HttpServer">
        function <span class="apidocSignatureSpan">hprose.</span>HttpServer
        <span class="apidocSignatureSpan">(port, hostname, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpServer(port, hostname, tlsOptions) {
    HttpService.call(this);

    var self = this;
    var server = (tlsOptions ?
        https.createServer(tlsOptions, self.handle) :
        http.createServer(self.handle));

    server.on(&#x27;clientError&#x27;, function (e, socket) {
        var context = { server: server, socket: socket, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(port, hostname);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.HttpServer.super_" id="apidoc.element.hprose.HttpServer.super_">
        function <span class="apidocSignatureSpan">hprose.HttpServer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpService() {
    Service.call(this);

    var _onSendHeader = null;
    var _crossDomain = true;
    var _P3P = true;
    var _get = true;
    var _origins = {};
    var _origincount = 0;
    var _crossDomainXmlFile = null;
    var _crossDomainXmlContent = null;
    var _clientAccessPolicyXmlFile = null;
    var _clientAccessPolicyXmlContent = null;
    var _lastModified = (new Date()).toUTCString();
    var _etag = &#x27;&#x22;&#x27; + Math.floor(Math.random() * 2147483647).toString(16) +
                &#x27;:&#x27; + Math.floor(Math.random() * 2147483647).toString(16) + &#x27;&#x22;&#x27;;

    var self = this;

    function getSendHeader() {
        return _onSendHeader;
    }

    function setSendHeader(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendHeader = value;
        }
        else {
            throw new Error(&#x27;onSendHeader must be a function or null.&#x27;);
        }
    }

    function crossDomainXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/crossdomain.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _crossDomainXmlContent.length);
                response.write(_crossDomainXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function clientAccessPolicyXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/clientaccesspolicy.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _clientAccessPolicyXmlContent.length);
                response.write(_clientAccessPolicyXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function sendHeader(context) {
        var resp = context.response;
        resp.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);
        if (_P3P) {
            resp.setHeader(&#x27;P3P&#x27;,
                &#x27;CP=&#x22;CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi &#x27; +
                &#x27;CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL &#x27; +
                &#x27;UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE GOV&#x22;&#x27;);
        }
        if (_crossDomain) {
            var origin = context.request.headers.origin;
            if (origin &#x26;&#x26; origin !== &#x27;null&#x27;) {
                if (_origincount === 0 || _origins[origin]) {
                    resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin);
                    resp.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);
                }
            }
            else {
                resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);
            }
        }
        self.emit(&#x27;sendHeader&#x27;, context);
        if (_onSendHeader !== null) {
            _onSendHeader(context);
        }
    }

    function isCrossDomainEnabled() {
        return _crossDomain;
    }

    function setCrossDomainEnabled(value) {
        _crossDomain = !!value;
    }

    function isP3PEnabled() {
        return _P3P;
    }

    function setP3PEnabled(value) {
        _P3P = !!value;
    }

    function isGetEnabled() {
        return _get;
    }

    function setGetEnabled(value) {
        _get = !!value;
    }

    function addAccessControlAllowOrigin(origin) {
        if (!_origins[origin]) {
            _origins[origin] = true;
            _origincount++;
        }
    }

    function removeAcces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.HttpService" id="apidoc.module.hprose.HttpService">module hprose.HttpService</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.HttpService.HttpService" id="apidoc.element.hprose.HttpService.HttpService">
        function <span class="apidocSignatureSpan">hprose.</span>HttpService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpService() {
    Service.call(this);

    var _onSendHeader = null;
    var _crossDomain = true;
    var _P3P = true;
    var _get = true;
    var _origins = {};
    var _origincount = 0;
    var _crossDomainXmlFile = null;
    var _crossDomainXmlContent = null;
    var _clientAccessPolicyXmlFile = null;
    var _clientAccessPolicyXmlContent = null;
    var _lastModified = (new Date()).toUTCString();
    var _etag = &#x27;&#x22;&#x27; + Math.floor(Math.random() * 2147483647).toString(16) +
                &#x27;:&#x27; + Math.floor(Math.random() * 2147483647).toString(16) + &#x27;&#x22;&#x27;;

    var self = this;

    function getSendHeader() {
        return _onSendHeader;
    }

    function setSendHeader(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendHeader = value;
        }
        else {
            throw new Error(&#x27;onSendHeader must be a function or null.&#x27;);
        }
    }

    function crossDomainXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/crossdomain.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _crossDomainXmlContent.length);
                response.write(_crossDomainXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function clientAccessPolicyXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/clientaccesspolicy.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _clientAccessPolicyXmlContent.length);
                response.write(_clientAccessPolicyXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function sendHeader(context) {
        var resp = context.response;
        resp.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);
        if (_P3P) {
            resp.setHeader(&#x27;P3P&#x27;,
                &#x27;CP=&#x22;CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi &#x27; +
                &#x27;CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL &#x27; +
                &#x27;UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE GOV&#x22;&#x27;);
        }
        if (_crossDomain) {
            var origin = context.request.headers.origin;
            if (origin &#x26;&#x26; origin !== &#x27;null&#x27;) {
                if (_origincount === 0 || _origins[origin]) {
                    resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin);
                    resp.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);
                }
            }
            else {
                resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);
            }
        }
        self.emit(&#x27;sendHeader&#x27;, context);
        if (_onSendHeader !== null) {
            _onSendHeader(context);
        }
    }

    function isCrossDomainEnabled() {
        return _crossDomain;
    }

    function setCrossDomainEnabled(value) {
        _crossDomain = !!value;
    }

    function isP3PEnabled() {
        return _P3P;
    }

    function setP3PEnabled(value) {
        _P3P = !!value;
    }

    function isGetEnabled() {
        return _get;
    }

    function setGetEnabled(value) {
        _get = !!value;
    }

    function addAccessControlAllowOrigin(origin) {
        if (!_origins[origin]) {
            _origins[origin] = true;
            _origincount++;
        }
    }

    function removeAcces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.HttpService.super_" id="apidoc.element.hprose.HttpService.super_">
        function <span class="apidocSignatureSpan">hprose.HttpService.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service() {
    EventEmitter.call(this);

    var _calls                  = {},
        _names                  = [],
        _filters                = [],
        _onBeforeInvoke         = null,
        _onAfterInvoke          = null,
        _onSendError            = null,
        _timeout                = 120000,
        _heartbeat              = 3000,
        _errorDelay             = 10000,
        _simple                 = false,
        _debug                  = false,
        _passContext            = false,
        _topics                 = {},
        _events                 = {},
        _invokeHandler          = invokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],

        self = this;

    function inputFilter(data, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            data = _filters[i].inputFilter(data, context);
        }
        return data;
    }

    function outputFilter(data, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            data = _filters[i].outputFilter(data, context);
        }
        return data;
    }

    function getBeforeInvoke() {
        return _onBeforeInvoke;
    }

    function setBeforeInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onBeforeInvoke = value;
        }
        else {
            throw new Error(&#x27;onBeforeInvoke must be a function or null.&#x27;);
        }
    }

    function getAfterInvoke() {
        return _onAfterInvoke;
    }

    function setAfterInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAfterInvoke = value;
        }
        else {
            throw new Error(&#x27;onAfterInvoke must be a function or null.&#x27;);
        }
    }

    function getSendError() {
        return _onSendError;
    }

    function setSendError(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendError = value;
        }
        else {
            throw new Error(&#x27;onSendError must be a function or null.&#x27;);
        }
    }

    function sendError(error, context) {
        if (!isError(error)) {
            error = new Error(error);
        }
        try {
            self.emit(&#x27;sendError&#x27;, error, context);
            if (_onSendError !== null) {
                var e = _onSendError(error, context);
                if (isError(e)) {
                    error = e;
                }
            }
        }
        catch(e) {
            error = e;
        }
        var stream = new BytesIO();
        var writer = new Writer(stream, true);
        stream.writeByte(Tags.TagError);
        writer.writeString(_debug ? error.stack : error.message);
        return stream;
    }

    function endError(error, context) {
        var stream = sendError(error, context);
        stream.writeByte(Tags.TagEnd);
        return stream.bytes;
    }

    function beforeInvoke(name, args, context) {
        try {
            self.emit(&#x27;beforeInvoke&#x27;, name, args, context.byref, context);
            if (_onBeforeInvoke !== null) {
                var value = _onBeforeInvoke(name, args, context.byref, context);
                if (isError(value)) { throw value; }
                if (Future.isPromise(value)) {
                    return value.then(function(e) {
                        if (isError(e)) { throw e; }
                        return invoke(name, args, context);
                    }).then(null, function(e) {
                        return sendError(e, context);
                    });
                }
            }
            return invoke(name, args, context).then(null, function(e) {
                return sendError(e, context);
            });
        }
        catch (e) {
            return sendError(e, context);
        }
    }

    function invokeHandler(name, args, context) {
        if ((&#x27;*&#x27; in _calls) &#x26;&#x26; (context.method === _calls[&#x27;*&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.JSONRPCClientFilter" id="apidoc.module.hprose.JSONRPCClientFilter">module hprose.JSONRPCClientFilter</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.JSONRPCClientFilter.JSONRPCClientFilter" id="apidoc.element.hprose.JSONRPCClientFilter.JSONRPCClientFilter">
        function <span class="apidocSignatureSpan">hprose.</span>JSONRPCClientFilter
        <span class="apidocSignatureSpan">(version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONRPCClientFilter(version) {
    this.version = version || &#x27;2.0&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.JSONRPCClientFilter.prototype" id="apidoc.module.hprose.JSONRPCClientFilter.prototype">module hprose.JSONRPCClientFilter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.JSONRPCClientFilter.prototype.inputFilter" id="apidoc.element.hprose.JSONRPCClientFilter.prototype.inputFilter">
        function <span class="apidocSignatureSpan">hprose.JSONRPCClientFilter.prototype.</span>inputFilter
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inputFilter(data) {
    var json = BytesIO.toString(data);
    if (json.charAt(0) === &#x27;{&#x27;) {
        json = &#x27;[&#x27; + json + &#x27;]&#x27;;
    }
    var responses = JSON.parse(json);
    var stream = new BytesIO();
    var writer = new Writer(stream, true);
    for (var i = 0, n = responses.length; i &#x3c; n; ++i) {
        var response = responses[i];
        if (response.error) {
            stream.writeByte(Tags.TagError);
            writer.writeString(response.error.message);
        }
        else {
            stream.writeByte(Tags.TagResult);
            writer.serialize(response.result);
        }
    }
    stream.writeByte(Tags.TagEnd);
    return stream.bytes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        request = _filters[i].outputFilter(request, context);
    }
    return request;
}

function inputFilter(response, context) {
    for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
        response = _filters[i].<span class="apidocCodeKeywordSpan">inputFilter</span>(response, context);
    }
    return response;
}

function beforeFilterHandler(request, context) {
    request = outputFilter(request, context);
    return _afterFilterHandler(request, context)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.JSONRPCClientFilter.prototype.outputFilter" id="apidoc.element.hprose.JSONRPCClientFilter.prototype.outputFilter">
        function <span class="apidocSignatureSpan">hprose.JSONRPCClientFilter.prototype.</span>outputFilter
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputFilter(data) {
    var requests = [];
    var stream = new BytesIO(data);
    var reader = new Reader(stream, false, false);
    var tag = stream.readByte();
    do {
        var request = {};
        if (tag === Tags.TagCall) {
            request.method = reader.readString();
            tag = stream.readByte();
            if (tag === Tags.TagList) {
                request.params = reader.readListWithoutTag();
                tag = stream.readByte();
            }
            if (tag === Tags.TagTrue) {
                tag = stream.readByte();
            }
        }
        if (this.version === &#x27;1.1&#x27;) {
            request.version = &#x27;1.1&#x27;;
        }
        else if (this.version === &#x27;2.0&#x27;) {
            request.jsonrpc = &#x27;2.0&#x27;;
        }
        request.id = s_id++;
        requests.push(request);
    } while (tag === Tags.TagCall);
    if (requests.length &#x3e; 1) {
        return JSON.stringify(requests);
    }
    return JSON.stringify(requests[0]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _afterFilterHandlers    = [],
    _options                = Object.create(null),

    self = this;

function outputFilter(request, context) {
    for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
        request = _filters[i].<span class="apidocCodeKeywordSpan">outputFilter</span>(request, context);
    }
    return request;
}

function inputFilter(response, context) {
    for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
        response = _filters[i].inputFilter(response, context);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.JSONRPCServiceFilter" id="apidoc.module.hprose.JSONRPCServiceFilter">module hprose.JSONRPCServiceFilter</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.JSONRPCServiceFilter.JSONRPCServiceFilter" id="apidoc.element.hprose.JSONRPCServiceFilter.JSONRPCServiceFilter">
        function <span class="apidocSignatureSpan">hprose.</span>JSONRPCServiceFilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONRPCServiceFilter() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.JSONRPCServiceFilter.prototype" id="apidoc.module.hprose.JSONRPCServiceFilter.prototype">module hprose.JSONRPCServiceFilter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.JSONRPCServiceFilter.prototype.inputFilter" id="apidoc.element.hprose.JSONRPCServiceFilter.prototype.inputFilter">
        function <span class="apidocSignatureSpan">hprose.JSONRPCServiceFilter.prototype.</span>inputFilter
        <span class="apidocSignatureSpan">(data, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inputFilter(data, context) {
    if (data.length &#x3e; 0) {
        if (data[0] === leftbracket || data[0] === leftbrace) {
            var json = BytesIO.toString(data);
            if (json.charAt(0) === &#x27;{&#x27;) {
                json = &#x27;[&#x27; + json + &#x27;]&#x27;;
            }
            var requests;
            try {
                requests = JSON.parse(json);
            }
            catch (e) {
                return data;
            }
            var bytes = new BytesIO();
            var writer = new Writer(bytes, true);
            context.userdata.jsonrpc = [];
            for (var i = 0, n = requests.length; i &#x3c; n; ++i) {
                var jsonrpc = {};
                var request = requests[i];
                if (request.id === undefined) {
                    jsonrpc.id = null;
                }
                else {
                    jsonrpc.id = request.id;
                }
                if (request.version) {
                    jsonrpc.version = request.version;
                }
                else if (request.jsonrpc) {
                    jsonrpc.version = request.jsonrpc;
                }
                else {
                    jsonrpc.version = &#x27;1.0&#x27;;
                }
                context.userdata.jsonrpc[i] = jsonrpc;
                if (request.method) {
                    bytes.writeByte(Tags.TagCall);
                    writer.writeString(request.method);
                    if (request.params &#x26;&#x26; request.params.length &#x3e; 0) {
                        writer.writeList(request.params);
                    }
                }
            }
            bytes.writeByte(Tags.TagEnd);
            data = bytes.bytes;
        }
    }
    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        request = _filters[i].outputFilter(request, context);
    }
    return request;
}

function inputFilter(response, context) {
    for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
        response = _filters[i].<span class="apidocCodeKeywordSpan">inputFilter</span>(response, context);
    }
    return response;
}

function beforeFilterHandler(request, context) {
    request = outputFilter(request, context);
    return _afterFilterHandler(request, context)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.JSONRPCServiceFilter.prototype.outputFilter" id="apidoc.element.hprose.JSONRPCServiceFilter.prototype.outputFilter">
        function <span class="apidocSignatureSpan">hprose.JSONRPCServiceFilter.prototype.</span>outputFilter
        <span class="apidocSignatureSpan">(data, context)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function outputFilter(data, context) {
    if (context.userdata.jsonrpc) {
        var jsonrpc = context.userdata.jsonrpc;
        var responses = [];
        var stream = new BytesIO(data);
        var reader = new Reader(stream, false, false);
        var tag = stream.readByte();
        var i = 0;
        do {
            var response = {};
            var version = jsonrpc[i].version;
            if (version !== &#x27;2.0&#x27;) {
                if (version === &#x27;1.1&#x27;) {
                    response.version = &#x27;1.1&#x27;;
                }
                response.result = null;
                response.error = null;
            }
            else {
                response.jsonrpc = &#x27;2.0&#x27;;
            }
            response.id = jsonrpc[i].id;
            if (tag === Tags.TagResult) {
                reader.reset();
                response.result = reader.unserialize();
                tag = stream.readByte();
            }
            else if (tag === Tags.TagError) {
                reader.reset();
                response.error = {
                    code: -1,
                    message: reader.readString()
                };
                tag = stream.readByte();
            }
            responses[i++] = response;
        } while (tag !== Tags.TagEnd);
        if (responses.length === 1) {
            responses = responses[0];
        }
        data = JSON.stringify(responses);
    }
    return data;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _afterFilterHandlers    = [],
    _options                = Object.create(null),

    self = this;

function outputFilter(request, context) {
    for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
        request = _filters[i].<span class="apidocCodeKeywordSpan">outputFilter</span>(request, context);
    }
    return request;
}

function inputFilter(response, context) {
    for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
        response = _filters[i].inputFilter(response, context);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.Reader" id="apidoc.module.hprose.Reader">module hprose.Reader</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.Reader.Reader" id="apidoc.element.hprose.Reader.Reader">
        function <span class="apidocSignatureSpan">hprose.</span>Reader
        <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(stream, simple, useHarmonyMap) {
    RawReader.call(this, stream);
    this.useHarmonyMap = !!useHarmonyMap;
    Object.defineProperties(this, {
        classref: { value: [] },
        refer: { value: simple ? fakeReaderRefer : realReaderRefer() }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.Reader.prototype" id="apidoc.module.hprose.Reader.prototype">module hprose.Reader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.Reader.prototype.constructor" id="apidoc.element.hprose.Reader.prototype.constructor">
        function <span class="apidocSignatureSpan">hprose.Reader.prototype.</span>constructor
        <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(stream, simple, useHarmonyMap) {
    RawReader.call(this, stream);
    this.useHarmonyMap = !!useHarmonyMap;
    Object.defineProperties(this, {
        classref: { value: [] },
        refer: { value: simple ? fakeReaderRefer : realReaderRefer() }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.Service" id="apidoc.module.hprose.Service">module hprose.Service</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.Service.Service" id="apidoc.element.hprose.Service.Service">
        function <span class="apidocSignatureSpan">hprose.</span>Service
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service() {
    EventEmitter.call(this);

    var _calls                  = {},
        _names                  = [],
        _filters                = [],
        _onBeforeInvoke         = null,
        _onAfterInvoke          = null,
        _onSendError            = null,
        _timeout                = 120000,
        _heartbeat              = 3000,
        _errorDelay             = 10000,
        _simple                 = false,
        _debug                  = false,
        _passContext            = false,
        _topics                 = {},
        _events                 = {},
        _invokeHandler          = invokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],

        self = this;

    function inputFilter(data, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            data = _filters[i].inputFilter(data, context);
        }
        return data;
    }

    function outputFilter(data, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            data = _filters[i].outputFilter(data, context);
        }
        return data;
    }

    function getBeforeInvoke() {
        return _onBeforeInvoke;
    }

    function setBeforeInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onBeforeInvoke = value;
        }
        else {
            throw new Error(&#x27;onBeforeInvoke must be a function or null.&#x27;);
        }
    }

    function getAfterInvoke() {
        return _onAfterInvoke;
    }

    function setAfterInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAfterInvoke = value;
        }
        else {
            throw new Error(&#x27;onAfterInvoke must be a function or null.&#x27;);
        }
    }

    function getSendError() {
        return _onSendError;
    }

    function setSendError(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendError = value;
        }
        else {
            throw new Error(&#x27;onSendError must be a function or null.&#x27;);
        }
    }

    function sendError(error, context) {
        if (!isError(error)) {
            error = new Error(error);
        }
        try {
            self.emit(&#x27;sendError&#x27;, error, context);
            if (_onSendError !== null) {
                var e = _onSendError(error, context);
                if (isError(e)) {
                    error = e;
                }
            }
        }
        catch(e) {
            error = e;
        }
        var stream = new BytesIO();
        var writer = new Writer(stream, true);
        stream.writeByte(Tags.TagError);
        writer.writeString(_debug ? error.stack : error.message);
        return stream;
    }

    function endError(error, context) {
        var stream = sendError(error, context);
        stream.writeByte(Tags.TagEnd);
        return stream.bytes;
    }

    function beforeInvoke(name, args, context) {
        try {
            self.emit(&#x27;beforeInvoke&#x27;, name, args, context.byref, context);
            if (_onBeforeInvoke !== null) {
                var value = _onBeforeInvoke(name, args, context.byref, context);
                if (isError(value)) { throw value; }
                if (Future.isPromise(value)) {
                    return value.then(function(e) {
                        if (isError(e)) { throw e; }
                        return invoke(name, args, context);
                    }).then(null, function(e) {
                        return sendError(e, context);
                    });
                }
            }
            return invoke(name, args, context).then(null, function(e) {
                return sendError(e, context);
            });
        }
        catch (e) {
            return sendError(e, context);
        }
    }

    function invokeHandler(name, args, context) {
        if ((&#x27;*&#x27; in _calls) &#x26;&#x26; (context.method === _calls[&#x27;*&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.Service.super_" id="apidoc.element.hprose.Service.super_">
        function <span class="apidocSignatureSpan">hprose.Service.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.SocketClient" id="apidoc.module.hprose.SocketClient">module hprose.SocketClient</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.SocketClient.SocketClient" id="apidoc.element.hprose.SocketClient.SocketClient">
        function <span class="apidocSignatureSpan">hprose.</span>SocketClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketClient(uri, functions, settings) {
    if (this.constructor !== SocketClient) {
        return new SocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var self = this;
    var _noDelay = true;
    var _fullDuplex = false;
    var _maxPoolSize = 10;
    var _poolTimeout = 30000;
    var fdtrans = null;
    var hdtrans = null;

    function getNoDelay() {
        return _noDelay;
    }

    function setNoDelay(value) {
        _noDelay = !!value;
    }

    function getFullDuplex() {
        return _fullDuplex;
    }

    function setFullDuplex(value) {
        _fullDuplex = !!value;
    }

    function getMaxPoolSize() {
        return _maxPoolSize;
    }

    function setMaxPoolSize(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _maxPoolSize = value | 0;
            if (_maxPoolSize &#x3c; 1) {
                _maxPoolSize = 10;
            }
        }
        else {
            _maxPoolSize = 10;
        }
    }

    function getPoolTimeout() {
        return _poolTimeout;
    }

    function setPoolTimeout(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _poolTimeout = value | 0;
        }
        else {
            _poolTimeout = 0;
        }
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        if (_fullDuplex) {
            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {
                fdtrans = new FullDuplexSocketTransporter(self);
            }
            fdtrans.sendAndReceive(request, future, context);
        }
        else {
            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {
                hdtrans = new HalfDuplexSocketTransporter(self);
            }
            hdtrans.sendAndReceive(request, future, context);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    Object.defineProperties(this, {
        noDelay: { get: getNoDelay, set: setNoDelay },
        fullDuplex: { get: getFullDuplex, set: setFullDuplex },
        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },
        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.SocketClient.super_" id="apidoc.element.hprose.SocketClient.super_">
        function <span class="apidocSignatureSpan">hprose.SocketClient.</span>super_
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(uri, functions, settings) {
    EventEmitter.call(this);
    this.on(&#x27;error&#x27;, noop);

    // private members
    var _uri,
        _uriList                = [],
        _index                  = -1,
        _byref                  = false,
        _simple                 = false,
        _timeout                = 30000,
        _retry                  = 10,
        _idempotent             = false,
        _failswitch             = false,
        _failround              = 0,
        _lock                   = false,
        _tasks                  = [],
        _useHarmonyMap          = false,
        _onerror                = noop,
        _onfailswitch           = noop,
        _filters                = [],
        _batch                  = false,
        _batches                = [],
        _ready                  = new Future(),
        _topics                 = Object.create(null),
        _id                     = null,
        _keepAlive              = true,
        _invokeHandler          = invokeHandler,
        _batchInvokeHandler     = batchInvokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _batchInvokeHandlers    = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],
        _options                = Object.create(null),

        self = this;

    function outputFilter(request, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            request = _filters[i].outputFilter(request, context);
        }
        return request;
    }

    function inputFilter(response, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            response = _filters[i].inputFilter(response, context);
        }
        return response;
    }

    function beforeFilterHandler(request, context) {
        request = outputFilter(request, context);
        return _afterFilterHandler(request, context)
        .then(function(response) {
            if (context.oneway) { return; }
            return inputFilter(response, context);
        });
    }

    function afterFilterHandler(request, context) {
         return self.sendAndReceive(request, context).catchError(function(e) {
             var response = retry(request, context);
             if (response !== null) {
                 return response;
             }
             throw e;
        });
    }

    function sendAndReceive(request, context, onsuccess, onerror) {
        _beforeFilterHandler(request, context).then(onsuccess, onerror);
    }

    function failswitch() {
        var n = _uriList.length;
        if (n &#x3e; 1) {
            var i = _index + 1;
            if (i &#x3e;= n) {
                i = 0;
                _failround++;
            }
            _index = i;
            _uri = _uriList[_index];
        }
        else {
            _failround++;
        }
        _onfailswitch(self);
        self.emit(&#x27;failswitch&#x27;, self);
    }

    function retry(data, context) {
        if (context.failswitch) {
            failswitch();
        }
        if (context.idempotent &#x26;&#x26; (context.retried &#x3c; context.retry)) {
            var interval = ++context.retried * 500;
            if (context.failswitch) {
                interval -= (_uriList.length - 1) * 500;
            }
            if (interval &#x3e; 5000) {
                interval = 5000;
            }
            if (interval &#x3e; 0) {
                return Future.delayed(interval, function() {
                    return afterFilterHandler(data, context);
                });
            }
            else {
                return afterFilterHandler(data, context);
            }
        }
        return null;
    }

    function initService(stub) {
        var context = {
            retry: _retry,
            retried: 0,
            idempotent: true,
            failswitch: true,
            timeout: _timeout,
            client: self,
            userdata: {}
        };
        var onsuccess = function(data) {
            var error = nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.SocketServer" id="apidoc.module.hprose.SocketServer">module hprose.SocketServer</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.SocketServer.SocketServer" id="apidoc.element.hprose.SocketServer.SocketServer">
        function <span class="apidocSignatureSpan">hprose.</span>SocketServer
        <span class="apidocSignatureSpan">(options, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketServer(options, tlsOptions) {
    SocketService.call(this);
    var self = this;
    var server = (tlsOptions ?
        tls.createServer(tlsOptions, self.handle) :
        net.createServer(self.handle));

    server.on(&#x27;error&#x27;, function (e) {
        var context = { server: server, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(options);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.SocketServer.super_" id="apidoc.element.hprose.SocketServer.super_">
        function <span class="apidocSignatureSpan">hprose.SocketServer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketService() {
    Service.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(socket, data, id) {
        var p = (id === null ? 4 : 8);
        var n = data.length;
        var buf = new Buffer(p + n);
        if (p === 8) {
            buf.writeInt32BE(n | 0x80000000, 0);
            buf.writeInt32BE(id, 4);
        }
        else {
            buf.writeUInt32BE(n, 0);
        }
        for (var i = 0; i &#x3c; n; i++) {
            buf[i + p] = data[i];
        }
        socket.write(buf);
    }

    function send(socket, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(socket, data, id); });
        }
        else {
            _send(socket, data, id);
        }
    }

    function run(socket, data, id) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        data = self.defaultHandle(data, context);
        send(socket, data, id);
    }

    function receive(socket) {
        var bytes = new BytesIO();
        var headerLength = 4;
        var dataLength = -1;
        var id = null;
        socket.on(&#x27;data&#x27;, function(chunk) {
            bytes.write(chunk);
            while (true) {
                if ((dataLength &#x3c; 0) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    dataLength = bytes.readInt32BE();
                    if ((dataLength &#x26; 0x80000000) !== 0) {
                        dataLength &#x26;= 0x7fffffff;
                        headerLength = 8;
                    }
                }
                if ((headerLength === 8) &#x26;&#x26; (id === null) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    id = bytes.readInt32BE();
                }
                if ((dataLength &#x3e;= 0) &#x26;&#x26; ((bytes.length - headerLength) &#x3e;= dataLength)) {
                    var data = bytes.read(dataLength);
                    run(socket, data, id);
                    bytes.trunc();
                    dataLength = -1;
                    headerLength = 4;
                    id = null;
                }
                else {
                    break;
                }
            }
        });
    }

    function handle(socket) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            socket.end();
            return;
        }
        socket.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;, context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        socket.on(&#x27;end&#x27;, noop);
        socket.on(&#x27;error&#x27;, function(e) {
            try {
                if (e.code != &#x22;EPIPE&#x22;) {
                    self.emit(&#x27;sendError&#x27;, e, context);
                    if (self.onSendError) {
                        self.onSendError(e, context);
                    }
                }
            }
            catch(e) {}
        });
        socket.setTimeout(self.timeout);
        receive(socket);
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        handle: { value: handle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.SocketService" id="apidoc.module.hprose.SocketService">module hprose.SocketService</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.SocketService.SocketService" id="apidoc.element.hprose.SocketService.SocketService">
        function <span class="apidocSignatureSpan">hprose.</span>SocketService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketService() {
    Service.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(socket, data, id) {
        var p = (id === null ? 4 : 8);
        var n = data.length;
        var buf = new Buffer(p + n);
        if (p === 8) {
            buf.writeInt32BE(n | 0x80000000, 0);
            buf.writeInt32BE(id, 4);
        }
        else {
            buf.writeUInt32BE(n, 0);
        }
        for (var i = 0; i &#x3c; n; i++) {
            buf[i + p] = data[i];
        }
        socket.write(buf);
    }

    function send(socket, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(socket, data, id); });
        }
        else {
            _send(socket, data, id);
        }
    }

    function run(socket, data, id) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        data = self.defaultHandle(data, context);
        send(socket, data, id);
    }

    function receive(socket) {
        var bytes = new BytesIO();
        var headerLength = 4;
        var dataLength = -1;
        var id = null;
        socket.on(&#x27;data&#x27;, function(chunk) {
            bytes.write(chunk);
            while (true) {
                if ((dataLength &#x3c; 0) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    dataLength = bytes.readInt32BE();
                    if ((dataLength &#x26; 0x80000000) !== 0) {
                        dataLength &#x26;= 0x7fffffff;
                        headerLength = 8;
                    }
                }
                if ((headerLength === 8) &#x26;&#x26; (id === null) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    id = bytes.readInt32BE();
                }
                if ((dataLength &#x3e;= 0) &#x26;&#x26; ((bytes.length - headerLength) &#x3e;= dataLength)) {
                    var data = bytes.read(dataLength);
                    run(socket, data, id);
                    bytes.trunc();
                    dataLength = -1;
                    headerLength = 4;
                    id = null;
                }
                else {
                    break;
                }
            }
        });
    }

    function handle(socket) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            socket.end();
            return;
        }
        socket.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;, context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        socket.on(&#x27;end&#x27;, noop);
        socket.on(&#x27;error&#x27;, function(e) {
            try {
                if (e.code != &#x22;EPIPE&#x22;) {
                    self.emit(&#x27;sendError&#x27;, e, context);
                    if (self.onSendError) {
                        self.onSendError(e, context);
                    }
                }
            }
            catch(e) {}
        });
        socket.setTimeout(self.timeout);
        receive(socket);
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        handle: { value: handle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.SocketService.super_" id="apidoc.element.hprose.SocketService.super_">
        function <span class="apidocSignatureSpan">hprose.SocketService.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service() {
    EventEmitter.call(this);

    var _calls                  = {},
        _names                  = [],
        _filters                = [],
        _onBeforeInvoke         = null,
        _onAfterInvoke          = null,
        _onSendError            = null,
        _timeout                = 120000,
        _heartbeat              = 3000,
        _errorDelay             = 10000,
        _simple                 = false,
        _debug                  = false,
        _passContext            = false,
        _topics                 = {},
        _events                 = {},
        _invokeHandler          = invokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],

        self = this;

    function inputFilter(data, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            data = _filters[i].inputFilter(data, context);
        }
        return data;
    }

    function outputFilter(data, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            data = _filters[i].outputFilter(data, context);
        }
        return data;
    }

    function getBeforeInvoke() {
        return _onBeforeInvoke;
    }

    function setBeforeInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onBeforeInvoke = value;
        }
        else {
            throw new Error(&#x27;onBeforeInvoke must be a function or null.&#x27;);
        }
    }

    function getAfterInvoke() {
        return _onAfterInvoke;
    }

    function setAfterInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAfterInvoke = value;
        }
        else {
            throw new Error(&#x27;onAfterInvoke must be a function or null.&#x27;);
        }
    }

    function getSendError() {
        return _onSendError;
    }

    function setSendError(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendError = value;
        }
        else {
            throw new Error(&#x27;onSendError must be a function or null.&#x27;);
        }
    }

    function sendError(error, context) {
        if (!isError(error)) {
            error = new Error(error);
        }
        try {
            self.emit(&#x27;sendError&#x27;, error, context);
            if (_onSendError !== null) {
                var e = _onSendError(error, context);
                if (isError(e)) {
                    error = e;
                }
            }
        }
        catch(e) {
            error = e;
        }
        var stream = new BytesIO();
        var writer = new Writer(stream, true);
        stream.writeByte(Tags.TagError);
        writer.writeString(_debug ? error.stack : error.message);
        return stream;
    }

    function endError(error, context) {
        var stream = sendError(error, context);
        stream.writeByte(Tags.TagEnd);
        return stream.bytes;
    }

    function beforeInvoke(name, args, context) {
        try {
            self.emit(&#x27;beforeInvoke&#x27;, name, args, context.byref, context);
            if (_onBeforeInvoke !== null) {
                var value = _onBeforeInvoke(name, args, context.byref, context);
                if (isError(value)) { throw value; }
                if (Future.isPromise(value)) {
                    return value.then(function(e) {
                        if (isError(e)) { throw e; }
                        return invoke(name, args, context);
                    }).then(null, function(e) {
                        return sendError(e, context);
                    });
                }
            }
            return invoke(name, args, context).then(null, function(e) {
                return sendError(e, context);
            });
        }
        catch (e) {
            return sendError(e, context);
        }
    }

    function invokeHandler(name, args, context) {
        if ((&#x27;*&#x27; in _calls) &#x26;&#x26; (context.method === _calls[&#x27;*&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.TimeoutError" id="apidoc.module.hprose.TimeoutError">module hprose.TimeoutError</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.TimeoutError.TimeoutError" id="apidoc.element.hprose.TimeoutError.TimeoutError">
        function <span class="apidocSignatureSpan">hprose.</span>TimeoutError
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
    Error.call(this);
    this.message = message;
    this.name = TimeoutError.name;
    if (typeof Error.captureStackTrace === &#x27;function&#x27;) {
        Error.captureStackTrace(this, TimeoutError);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.TimeoutError.prototype" id="apidoc.module.hprose.TimeoutError.prototype">module hprose.TimeoutError.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.TimeoutError.prototype.constructor" id="apidoc.element.hprose.TimeoutError.prototype.constructor">
        function <span class="apidocSignatureSpan">hprose.TimeoutError.prototype.</span>constructor
        <span class="apidocSignatureSpan">(message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function TimeoutError(message) {
    Error.call(this);
    this.message = message;
    this.name = TimeoutError.name;
    if (typeof Error.captureStackTrace === &#x27;function&#x27;) {
        Error.captureStackTrace(this, TimeoutError);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.WebSocketClient" id="apidoc.module.hprose.WebSocketClient">module hprose.WebSocketClient</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.WebSocketClient.WebSocketClient" id="apidoc.element.hprose.WebSocketClient.WebSocketClient">
        function <span class="apidocSignatureSpan">hprose.</span>WebSocketClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketClient(uri, functions, settings) {
    if (this.constructor !== WebSocketClient) {
        return new WebSocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var _id = 0;
    var _count = 0;
    var _futures = [];
    var _requests = [];
    var _ready = null;
    var ws = null;

    var self = this;

    function getNextId() {
        return (_id &#x3c; 0x7fffffff) ? ++_id : _id = 0;
    }

    function send(id, request) {
        var bytes = new BytesIO();
        bytes.writeInt32BE(id);
        if (request.constructor === String) {
            bytes.writeString(request);
        }
        else {
            bytes.write(request);
        }
        var future = _futures[id];
        try {
            ws.send(bytes.bytes);
        }
        catch (e) {
            future.reject(e);
        }
    }
    function onopen() {
        _ready.resolve();
    }
    function onmessage(data) {
        var bytes = new BytesIO(data);
        var id = bytes.readInt32BE();
        var future = _futures[id];
        delete _futures[id];
        if (future !== undefined) {
            --_count;
            future.resolve(bytes.read(bytes.length - 4));
        }
        if ((_count &#x3c; 100) &#x26;&#x26; (_requests.length &#x3e; 0)) {
            ++_count;
            var request = _requests.pop();
            _ready.then(function() { send(request[0], request[1]); });
        }
        if (_count === 0) {
            if (!self.keepAlive) { close(); }
        }
    }
    function onclose(code, message) {
        onerror(new Error(code + &#x27;:&#x27; + message));
        ws = null;
    }
    function onerror(error) {
        _futures.forEach(function(future, id) {
            future.reject(error);
            delete _futures[id];
        });
        _count = 0;
    }
    function connect() {
        _ready = new Future();
        self.setOption(&#x27;perMessageDeflate&#x27;, false);
        ws = new WebSocket(self.uri, self.options);
        ws.on(&#x27;open&#x27;, onopen);
        ws.on(&#x27;message&#x27;, onmessage);
        ws.on(&#x27;error&#x27;, onerror);
        ws.on(&#x27;close&#x27;, onclose);
    }
    function sendAndReceive(request, context) {
        var id = getNextId();
        var future = new Future();
        _futures[id] = future;
        if (context.timeout &#x3e; 0) {
            future = future.timeout(context.timeout).catchError(function(e) {
                delete _futures[id];
                --_count;
                throw e;
            },
            function(e) {
                return e instanceof TimeoutError;
            });
        }
        if (ws === null ||
            ws.readyState === WebSocket.CLOSING ||
            ws.readyState === WebSocket.CLOSED) {
            connect();
        }
        if (_count &#x3c; 100) {
            ++_count;
            _ready.then(function() { send(id, request); });
        }
        else {
            _requests.push([id, request]);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }
    function close() {
        if (ws !== null) {
            ws.removeAllListeners(&#x27;open&#x27;);
            ws.removeAllListeners(&#x27;message&#x27;);
            ws.removeAllListeners(&#x27;error&#x27;);
            ws.removeAllListeners(&#x27;close&#x27;);
            ws.close();
        }
    }
    Object.defineProperties(this, {
        sendAndReceive: { value: sendAndReceive },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.WebSocketClient.super_" id="apidoc.element.hprose.WebSocketClient.super_">
        function <span class="apidocSignatureSpan">hprose.WebSocketClient.</span>super_
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(uri, functions, settings) {
    EventEmitter.call(this);
    this.on(&#x27;error&#x27;, noop);

    // private members
    var _uri,
        _uriList                = [],
        _index                  = -1,
        _byref                  = false,
        _simple                 = false,
        _timeout                = 30000,
        _retry                  = 10,
        _idempotent             = false,
        _failswitch             = false,
        _failround              = 0,
        _lock                   = false,
        _tasks                  = [],
        _useHarmonyMap          = false,
        _onerror                = noop,
        _onfailswitch           = noop,
        _filters                = [],
        _batch                  = false,
        _batches                = [],
        _ready                  = new Future(),
        _topics                 = Object.create(null),
        _id                     = null,
        _keepAlive              = true,
        _invokeHandler          = invokeHandler,
        _batchInvokeHandler     = batchInvokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _batchInvokeHandlers    = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],
        _options                = Object.create(null),

        self = this;

    function outputFilter(request, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            request = _filters[i].outputFilter(request, context);
        }
        return request;
    }

    function inputFilter(response, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            response = _filters[i].inputFilter(response, context);
        }
        return response;
    }

    function beforeFilterHandler(request, context) {
        request = outputFilter(request, context);
        return _afterFilterHandler(request, context)
        .then(function(response) {
            if (context.oneway) { return; }
            return inputFilter(response, context);
        });
    }

    function afterFilterHandler(request, context) {
         return self.sendAndReceive(request, context).catchError(function(e) {
             var response = retry(request, context);
             if (response !== null) {
                 return response;
             }
             throw e;
        });
    }

    function sendAndReceive(request, context, onsuccess, onerror) {
        _beforeFilterHandler(request, context).then(onsuccess, onerror);
    }

    function failswitch() {
        var n = _uriList.length;
        if (n &#x3e; 1) {
            var i = _index + 1;
            if (i &#x3e;= n) {
                i = 0;
                _failround++;
            }
            _index = i;
            _uri = _uriList[_index];
        }
        else {
            _failround++;
        }
        _onfailswitch(self);
        self.emit(&#x27;failswitch&#x27;, self);
    }

    function retry(data, context) {
        if (context.failswitch) {
            failswitch();
        }
        if (context.idempotent &#x26;&#x26; (context.retried &#x3c; context.retry)) {
            var interval = ++context.retried * 500;
            if (context.failswitch) {
                interval -= (_uriList.length - 1) * 500;
            }
            if (interval &#x3e; 5000) {
                interval = 5000;
            }
            if (interval &#x3e; 0) {
                return Future.delayed(interval, function() {
                    return afterFilterHandler(data, context);
                });
            }
            else {
                return afterFilterHandler(data, context);
            }
        }
        return null;
    }

    function initService(stub) {
        var context = {
            retry: _retry,
            retried: 0,
            idempotent: true,
            failswitch: true,
            timeout: _timeout,
            client: self,
            userdata: {}
        };
        var onsuccess = function(data) {
            var error = nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.WebSocketServer" id="apidoc.module.hprose.WebSocketServer">module hprose.WebSocketServer</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.WebSocketServer.WebSocketServer" id="apidoc.element.hprose.WebSocketServer.WebSocketServer">
        function <span class="apidocSignatureSpan">hprose.</span>WebSocketServer
        <span class="apidocSignatureSpan">(options, tlsOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, tlsOptions, handler) {
    WebSocketService.call(this);
    var self = this;
    if (!handler) handler = this.handle;
    var httpserver = tlsOptions ?
        https.createServer(tlsOptions, handler) :
        http.createServer(handler);
    var host = options.host;
    var port = options.port;
    delete options.host;
    delete options.port;
    options.server = httpserver;
    options.perMessageDeflate = false;
    var server = null;

    function onerror(e, socket) {
        var context = {
            httpserver: httpserver,
            server: self.server,
            userdata:{}
        };
        if (socket) { context.socket = socket; }
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    }

    httpserver.on(&#x27;clientError&#x27;, onerror);

    function start() {
        httpserver.listen(port, host);
        server = new ws.Server(options);
        server.on(&#x27;connection&#x27;, self.wsHandle);
        server.on(&#x27;error&#x27;, onerror);
    }
    function stop() {
        server.close();
        httpserver.close();
    }
    function listen() {
        httpserver.listen.apply(httpserver, arguments);
        server = new ws.Server(options);
        server.on(&#x27;connection&#x27;, self.wsHandle);
        server.on(&#x27;error&#x27;, onerror);
    }
    function close(callback) {
        server.close();
        httpserver.close(callback);
    }

    Object.defineProperties(this, {
        httpserver: { get: function () { return httpserver; } },
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.WebSocketServer.super_" id="apidoc.element.hprose.WebSocketServer.super_">
        function <span class="apidocSignatureSpan">hprose.WebSocketServer.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketService() {
    HttpService.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(ws, data, id) {
        var bytes = new BytesIO();
        bytes.writeInt32BE(id);
        if (data.constructor === String) {
            bytes.writeString(data);
        }
        else {
            bytes.write(data);
        }
        try {
            ws.send(bytes.bytes, {
                binary: true,
                compress: false
            });
        }
        catch (e) {
            ws.emit(&#x27;error&#x27;, e);
        }
    }

    function send(ws, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(ws, data, id); });
        }
        else {
            _send(ws, data, id);
        }
    }

    function wsHandle(ws) {
        var context = {
            httpserver: self.httpserver,
            server: self.server,
            websocket: ws,
            socket: ws._socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            ws.close();
            return;
        }
        ws.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;,context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        ws.on(&#x27;error&#x27;, function(e) {
            try {
                self.emit(&#x27;sendError&#x27;, e, context);
                if (self.onSendError) {
                    self.onSendError(e, context);
                }
            }
            catch(e) {}
        });
        ws.on(&#x27;message&#x27;, function(data) {
            var bytes = new BytesIO(data);
            var id = bytes.readInt32BE();
            var request = bytes.read(bytes.length - 4);
            process.nextTick(function() {
                var context = {
                    httpserver: self.httpserver,
                    server: self.server,
                    websocket: ws,
                    socket: ws._socket,
                    userdata: {}
                };
                data = self.defaultHandle(request, context);
                send(ws, data, id);
            });
        });
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        wsHandle: { value: wsHandle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.WebSocketService" id="apidoc.module.hprose.WebSocketService">module hprose.WebSocketService</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.WebSocketService.WebSocketService" id="apidoc.element.hprose.WebSocketService.WebSocketService">
        function <span class="apidocSignatureSpan">hprose.</span>WebSocketService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketService() {
    HttpService.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(ws, data, id) {
        var bytes = new BytesIO();
        bytes.writeInt32BE(id);
        if (data.constructor === String) {
            bytes.writeString(data);
        }
        else {
            bytes.write(data);
        }
        try {
            ws.send(bytes.bytes, {
                binary: true,
                compress: false
            });
        }
        catch (e) {
            ws.emit(&#x27;error&#x27;, e);
        }
    }

    function send(ws, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(ws, data, id); });
        }
        else {
            _send(ws, data, id);
        }
    }

    function wsHandle(ws) {
        var context = {
            httpserver: self.httpserver,
            server: self.server,
            websocket: ws,
            socket: ws._socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            ws.close();
            return;
        }
        ws.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;,context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        ws.on(&#x27;error&#x27;, function(e) {
            try {
                self.emit(&#x27;sendError&#x27;, e, context);
                if (self.onSendError) {
                    self.onSendError(e, context);
                }
            }
            catch(e) {}
        });
        ws.on(&#x27;message&#x27;, function(data) {
            var bytes = new BytesIO(data);
            var id = bytes.readInt32BE();
            var request = bytes.read(bytes.length - 4);
            process.nextTick(function() {
                var context = {
                    httpserver: self.httpserver,
                    server: self.server,
                    websocket: ws,
                    socket: ws._socket,
                    userdata: {}
                };
                data = self.defaultHandle(request, context);
                send(ws, data, id);
            });
        });
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        wsHandle: { value: wsHandle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.WebSocketService.super_" id="apidoc.element.hprose.WebSocketService.super_">
        function <span class="apidocSignatureSpan">hprose.WebSocketService.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpService() {
    Service.call(this);

    var _onSendHeader = null;
    var _crossDomain = true;
    var _P3P = true;
    var _get = true;
    var _origins = {};
    var _origincount = 0;
    var _crossDomainXmlFile = null;
    var _crossDomainXmlContent = null;
    var _clientAccessPolicyXmlFile = null;
    var _clientAccessPolicyXmlContent = null;
    var _lastModified = (new Date()).toUTCString();
    var _etag = &#x27;&#x22;&#x27; + Math.floor(Math.random() * 2147483647).toString(16) +
                &#x27;:&#x27; + Math.floor(Math.random() * 2147483647).toString(16) + &#x27;&#x22;&#x27;;

    var self = this;

    function getSendHeader() {
        return _onSendHeader;
    }

    function setSendHeader(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendHeader = value;
        }
        else {
            throw new Error(&#x27;onSendHeader must be a function or null.&#x27;);
        }
    }

    function crossDomainXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/crossdomain.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _crossDomainXmlContent.length);
                response.write(_crossDomainXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function clientAccessPolicyXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/clientaccesspolicy.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _clientAccessPolicyXmlContent.length);
                response.write(_clientAccessPolicyXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function sendHeader(context) {
        var resp = context.response;
        resp.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);
        if (_P3P) {
            resp.setHeader(&#x27;P3P&#x27;,
                &#x27;CP=&#x22;CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi &#x27; +
                &#x27;CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL &#x27; +
                &#x27;UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE GOV&#x22;&#x27;);
        }
        if (_crossDomain) {
            var origin = context.request.headers.origin;
            if (origin &#x26;&#x26; origin !== &#x27;null&#x27;) {
                if (_origincount === 0 || _origins[origin]) {
                    resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin);
                    resp.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);
                }
            }
            else {
                resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);
            }
        }
        self.emit(&#x27;sendHeader&#x27;, context);
        if (_onSendHeader !== null) {
            _onSendHeader(context);
        }
    }

    function isCrossDomainEnabled() {
        return _crossDomain;
    }

    function setCrossDomainEnabled(value) {
        _crossDomain = !!value;
    }

    function isP3PEnabled() {
        return _P3P;
    }

    function setP3PEnabled(value) {
        _P3P = !!value;
    }

    function isGetEnabled() {
        return _get;
    }

    function setGetEnabled(value) {
        _get = !!value;
    }

    function addAccessControlAllowOrigin(origin) {
        if (!_origins[origin]) {
            _origins[origin] = true;
            _origincount++;
        }
    }

    function removeAcces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.client" id="apidoc.module.hprose.client">module hprose.client</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.client.Client" id="apidoc.element.hprose.client.Client">
        function <span class="apidocSignatureSpan">hprose.client.</span>Client
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Client(uri, functions, settings) {
    EventEmitter.call(this);
    this.on(&#x27;error&#x27;, noop);

    // private members
    var _uri,
        _uriList                = [],
        _index                  = -1,
        _byref                  = false,
        _simple                 = false,
        _timeout                = 30000,
        _retry                  = 10,
        _idempotent             = false,
        _failswitch             = false,
        _failround              = 0,
        _lock                   = false,
        _tasks                  = [],
        _useHarmonyMap          = false,
        _onerror                = noop,
        _onfailswitch           = noop,
        _filters                = [],
        _batch                  = false,
        _batches                = [],
        _ready                  = new Future(),
        _topics                 = Object.create(null),
        _id                     = null,
        _keepAlive              = true,
        _invokeHandler          = invokeHandler,
        _batchInvokeHandler     = batchInvokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _batchInvokeHandlers    = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],
        _options                = Object.create(null),

        self = this;

    function outputFilter(request, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            request = _filters[i].outputFilter(request, context);
        }
        return request;
    }

    function inputFilter(response, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            response = _filters[i].inputFilter(response, context);
        }
        return response;
    }

    function beforeFilterHandler(request, context) {
        request = outputFilter(request, context);
        return _afterFilterHandler(request, context)
        .then(function(response) {
            if (context.oneway) { return; }
            return inputFilter(response, context);
        });
    }

    function afterFilterHandler(request, context) {
         return self.sendAndReceive(request, context).catchError(function(e) {
             var response = retry(request, context);
             if (response !== null) {
                 return response;
             }
             throw e;
        });
    }

    function sendAndReceive(request, context, onsuccess, onerror) {
        _beforeFilterHandler(request, context).then(onsuccess, onerror);
    }

    function failswitch() {
        var n = _uriList.length;
        if (n &#x3e; 1) {
            var i = _index + 1;
            if (i &#x3e;= n) {
                i = 0;
                _failround++;
            }
            _index = i;
            _uri = _uriList[_index];
        }
        else {
            _failround++;
        }
        _onfailswitch(self);
        self.emit(&#x27;failswitch&#x27;, self);
    }

    function retry(data, context) {
        if (context.failswitch) {
            failswitch();
        }
        if (context.idempotent &#x26;&#x26; (context.retried &#x3c; context.retry)) {
            var interval = ++context.retried * 500;
            if (context.failswitch) {
                interval -= (_uriList.length - 1) * 500;
            }
            if (interval &#x3e; 5000) {
                interval = 5000;
            }
            if (interval &#x3e; 0) {
                return Future.delayed(interval, function() {
                    return afterFilterHandler(data, context);
                });
            }
            else {
                return afterFilterHandler(data, context);
            }
        }
        return null;
    }

    function initService(stub) {
        var context = {
            retry: _retry,
            retried: 0,
            idempotent: true,
            failswitch: true,
            timeout: _timeout,
            client: self,
            userdata: {}
        };
        var onsuccess = function(data) {
            var error = nu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.client.HttpClient" id="apidoc.element.hprose.client.HttpClient">
        function <span class="apidocSignatureSpan">hprose.client.</span>HttpClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpClient(uri, functions, settings) {
    if (this.constructor !== HttpClient) {
        return new HttpClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);
    var _header = Object.create(null);

    var self = this;

    function getRequestHeader(headers) {
        var header = Object.create(null);
        var name, value;
        for (name in _header) {
            header[name] = _header[name];
        }
        if (headers) {
            for (name in headers) {
                value = headers[name];
                if (Array.isArray(value)) {
                    header[name] = value.join(&#x27;, &#x27;);
                }
                else {
                    header[name] = value;
                }
            }
        }
        return header;
    }

    function send(request, future, context) {
        request = BytesIO.toBuffer(request);
        var options = parse(self.uri);
        var protocol = options.protocol;
        var client;
        var secure;
        if (protocol === &#x27;http:&#x27;) {
            client = http;
            secure = false;
        }
        else if (protocol === &#x27;https:&#x27;) {
            client = https;
            secure = true;
        }
        else {
            throw new Error(&#x27;Unsupported &#x27; + protocol + &#x27; protocol!&#x27;);
        }
        options.keepAlive = self.keepAlive;
        for (var key in self.options) {
            options[key] = self.options[key];
        }
        options.method = &#x27;POST&#x27;;
        options.headers = getRequestHeader(context.httpHeader);
        options.headers[&#x27;Content-Length&#x27;] = request.length;
        var cookie = getCookie(options.host, options.path, secure);
        if (cookie !== &#x27;&#x27;) {
            options.headers.Cookie = cookie;
        }
        var req = client.request(options, function(resp) {
            context.httpHeader = resp.headers;
            var bytes = new BytesIO();
            resp.on(&#x27;data&#x27;, function(data) { bytes.write(data); });
            resp.on(&#x27;end&#x27;, function() {
                if (resp.statusCode === 200) {
                    future.resolve(bytes.bytes);
                }
                else {
                    future.reject(new Error(resp.statusCode + &#x27;:&#x27; + bytes.toString()));
                }
            });
            resp.on(&#x27;error&#x27;, future.reject);
            if (resp.statusCode === 200) {
                setCookie(resp.headers, options.host);
            }
        });
        req.on(&#x27;error&#x27;, future.reject);
        req.end(request);
        return req;
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        var req = send(request, future, context);
        if (context.timeout &#x3e; 0) {
            future = future.timeout(context.timeout).catchError(function(e) {
                req.removeAllListeners(&#x27;error&#x27;);
                req.on(&#x27;error&#x27;, noop);
                req.abort();
                throw e;
            },
            function(e) {
                return e instanceof TimeoutError;
            });
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    function setHeader(name, value) {
        if (name.toLowerCase() !== &#x27;content-type&#x27; &#x26;&#x26;
            name.toLowerCase() !== &#x27;content-length&#x27; &#x26;&#x26;
            name.toLowerCase() !== &#x27;host&#x27;) {
            if (value) {
                _header[name] = value;
            }
            else {
                delete _header[name];
            }
        }
    }

    Object.defineProperties(this, {
        setHeader: { value: setHeader },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.client.SocketClient" id="apidoc.element.hprose.client.SocketClient">
        function <span class="apidocSignatureSpan">hprose.client.</span>SocketClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketClient(uri, functions, settings) {
    if (this.constructor !== SocketClient) {
        return new SocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var self = this;
    var _noDelay = true;
    var _fullDuplex = false;
    var _maxPoolSize = 10;
    var _poolTimeout = 30000;
    var fdtrans = null;
    var hdtrans = null;

    function getNoDelay() {
        return _noDelay;
    }

    function setNoDelay(value) {
        _noDelay = !!value;
    }

    function getFullDuplex() {
        return _fullDuplex;
    }

    function setFullDuplex(value) {
        _fullDuplex = !!value;
    }

    function getMaxPoolSize() {
        return _maxPoolSize;
    }

    function setMaxPoolSize(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _maxPoolSize = value | 0;
            if (_maxPoolSize &#x3c; 1) {
                _maxPoolSize = 10;
            }
        }
        else {
            _maxPoolSize = 10;
        }
    }

    function getPoolTimeout() {
        return _poolTimeout;
    }

    function setPoolTimeout(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _poolTimeout = value | 0;
        }
        else {
            _poolTimeout = 0;
        }
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        if (_fullDuplex) {
            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {
                fdtrans = new FullDuplexSocketTransporter(self);
            }
            fdtrans.sendAndReceive(request, future, context);
        }
        else {
            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {
                hdtrans = new HalfDuplexSocketTransporter(self);
            }
            hdtrans.sendAndReceive(request, future, context);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    Object.defineProperties(this, {
        noDelay: { get: getNoDelay, set: setNoDelay },
        fullDuplex: { get: getFullDuplex, set: setFullDuplex },
        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },
        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.client.TcpClient" id="apidoc.element.hprose.client.TcpClient">
        function <span class="apidocSignatureSpan">hprose.client.</span>TcpClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketClient(uri, functions, settings) {
    if (this.constructor !== SocketClient) {
        return new SocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var self = this;
    var _noDelay = true;
    var _fullDuplex = false;
    var _maxPoolSize = 10;
    var _poolTimeout = 30000;
    var fdtrans = null;
    var hdtrans = null;

    function getNoDelay() {
        return _noDelay;
    }

    function setNoDelay(value) {
        _noDelay = !!value;
    }

    function getFullDuplex() {
        return _fullDuplex;
    }

    function setFullDuplex(value) {
        _fullDuplex = !!value;
    }

    function getMaxPoolSize() {
        return _maxPoolSize;
    }

    function setMaxPoolSize(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _maxPoolSize = value | 0;
            if (_maxPoolSize &#x3c; 1) {
                _maxPoolSize = 10;
            }
        }
        else {
            _maxPoolSize = 10;
        }
    }

    function getPoolTimeout() {
        return _poolTimeout;
    }

    function setPoolTimeout(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _poolTimeout = value | 0;
        }
        else {
            _poolTimeout = 0;
        }
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        if (_fullDuplex) {
            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {
                fdtrans = new FullDuplexSocketTransporter(self);
            }
            fdtrans.sendAndReceive(request, future, context);
        }
        else {
            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {
                hdtrans = new HalfDuplexSocketTransporter(self);
            }
            hdtrans.sendAndReceive(request, future, context);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    Object.defineProperties(this, {
        noDelay: { get: getNoDelay, set: setNoDelay },
        fullDuplex: { get: getFullDuplex, set: setFullDuplex },
        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },
        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.client.UnixClient" id="apidoc.element.hprose.client.UnixClient">
        function <span class="apidocSignatureSpan">hprose.client.</span>UnixClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketClient(uri, functions, settings) {
    if (this.constructor !== SocketClient) {
        return new SocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var self = this;
    var _noDelay = true;
    var _fullDuplex = false;
    var _maxPoolSize = 10;
    var _poolTimeout = 30000;
    var fdtrans = null;
    var hdtrans = null;

    function getNoDelay() {
        return _noDelay;
    }

    function setNoDelay(value) {
        _noDelay = !!value;
    }

    function getFullDuplex() {
        return _fullDuplex;
    }

    function setFullDuplex(value) {
        _fullDuplex = !!value;
    }

    function getMaxPoolSize() {
        return _maxPoolSize;
    }

    function setMaxPoolSize(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _maxPoolSize = value | 0;
            if (_maxPoolSize &#x3c; 1) {
                _maxPoolSize = 10;
            }
        }
        else {
            _maxPoolSize = 10;
        }
    }

    function getPoolTimeout() {
        return _poolTimeout;
    }

    function setPoolTimeout(value) {
        if (typeof(value) === &#x27;number&#x27;) {
            _poolTimeout = value | 0;
        }
        else {
            _poolTimeout = 0;
        }
    }

    function sendAndReceive(request, context) {
        var future = new Future();
        if (_fullDuplex) {
            if ((fdtrans === null) || (fdtrans.uri !== self.uri)) {
                fdtrans = new FullDuplexSocketTransporter(self);
            }
            fdtrans.sendAndReceive(request, future, context);
        }
        else {
            if ((hdtrans === null) || (hdtrans.uri !== self.uri)) {
                hdtrans = new HalfDuplexSocketTransporter(self);
            }
            hdtrans.sendAndReceive(request, future, context);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }

    Object.defineProperties(this, {
        noDelay: { get: getNoDelay, set: setNoDelay },
        fullDuplex: { get: getFullDuplex, set: setFullDuplex },
        maxPoolSize: { get: getMaxPoolSize, set: setMaxPoolSize },
        poolTimeout: { get: getPoolTimeout, set: setPoolTimeout },
        sendAndReceive: { value: sendAndReceive }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.client.WebSocketClient" id="apidoc.element.hprose.client.WebSocketClient">
        function <span class="apidocSignatureSpan">hprose.client.</span>WebSocketClient
        <span class="apidocSignatureSpan">(uri, functions, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketClient(uri, functions, settings) {
    if (this.constructor !== WebSocketClient) {
        return new WebSocketClient(uri, functions, settings);
    }
    Client.call(this, uri, functions, settings);

    var _id = 0;
    var _count = 0;
    var _futures = [];
    var _requests = [];
    var _ready = null;
    var ws = null;

    var self = this;

    function getNextId() {
        return (_id &#x3c; 0x7fffffff) ? ++_id : _id = 0;
    }

    function send(id, request) {
        var bytes = new BytesIO();
        bytes.writeInt32BE(id);
        if (request.constructor === String) {
            bytes.writeString(request);
        }
        else {
            bytes.write(request);
        }
        var future = _futures[id];
        try {
            ws.send(bytes.bytes);
        }
        catch (e) {
            future.reject(e);
        }
    }
    function onopen() {
        _ready.resolve();
    }
    function onmessage(data) {
        var bytes = new BytesIO(data);
        var id = bytes.readInt32BE();
        var future = _futures[id];
        delete _futures[id];
        if (future !== undefined) {
            --_count;
            future.resolve(bytes.read(bytes.length - 4));
        }
        if ((_count &#x3c; 100) &#x26;&#x26; (_requests.length &#x3e; 0)) {
            ++_count;
            var request = _requests.pop();
            _ready.then(function() { send(request[0], request[1]); });
        }
        if (_count === 0) {
            if (!self.keepAlive) { close(); }
        }
    }
    function onclose(code, message) {
        onerror(new Error(code + &#x27;:&#x27; + message));
        ws = null;
    }
    function onerror(error) {
        _futures.forEach(function(future, id) {
            future.reject(error);
            delete _futures[id];
        });
        _count = 0;
    }
    function connect() {
        _ready = new Future();
        self.setOption(&#x27;perMessageDeflate&#x27;, false);
        ws = new WebSocket(self.uri, self.options);
        ws.on(&#x27;open&#x27;, onopen);
        ws.on(&#x27;message&#x27;, onmessage);
        ws.on(&#x27;error&#x27;, onerror);
        ws.on(&#x27;close&#x27;, onclose);
    }
    function sendAndReceive(request, context) {
        var id = getNextId();
        var future = new Future();
        _futures[id] = future;
        if (context.timeout &#x3e; 0) {
            future = future.timeout(context.timeout).catchError(function(e) {
                delete _futures[id];
                --_count;
                throw e;
            },
            function(e) {
                return e instanceof TimeoutError;
            });
        }
        if (ws === null ||
            ws.readyState === WebSocket.CLOSING ||
            ws.readyState === WebSocket.CLOSED) {
            connect();
        }
        if (_count &#x3c; 100) {
            ++_count;
            _ready.then(function() { send(id, request); });
        }
        else {
            _requests.push([id, request]);
        }
        if (context.oneway) { future.resolve(); }
        return future;
    }
    function close() {
        if (ws !== null) {
            ws.removeAllListeners(&#x27;open&#x27;);
            ws.removeAllListeners(&#x27;message&#x27;);
            ws.removeAllListeners(&#x27;error&#x27;);
            ws.removeAllListeners(&#x27;close&#x27;);
            ws.close();
        }
    }
    Object.defineProperties(this, {
        sendAndReceive: { value: sendAndReceive },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.co" id="apidoc.module.hprose.co">module hprose.co</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.co.co" id="apidoc.element.hprose.co.co">
        function <span class="apidocSignatureSpan">hprose.</span>co
        <span class="apidocSignatureSpan">(gen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function co(gen) {
    var thisArg = (function() { return this; })();
    if (typeof gen === &#x27;function&#x27;) {
        var args = slice.call(arguments, 1);
        gen = gen.apply(thisArg, args);
    }

    if (!gen || typeof gen.next !== &#x27;function&#x27;) {
        return toFuture(gen);
    }

    var future = new Future();

    function onFulfilled(res) {
        try {
            next(gen.next(res));
        }
        catch (e) {
            future.reject(e);
        }
    }

    function onRejected(err) {
        try {
            next(gen[&#x27;throw&#x27;](err));
        }
        catch (e) {
            future.reject(e);
        }
    }

    function next(ret) {
        if (ret.done) {
            future.resolve(ret.value);
        }
        else {
            ((&#x27;function&#x27; == typeof ret.value) ?
            thunkToPromise(ret.value) :
            toPromise(ret.value)).then(onFulfilled, onRejected);
        }
    }

    onFulfilled();

    return future;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.co.wrap" id="apidoc.element.hprose.co.wrap">
        function <span class="apidocSignatureSpan">hprose.co.</span>wrap
        <span class="apidocSignatureSpan">(handler, thisArg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(handler, thisArg) {
    return function() {
        thisArg = thisArg || this;
        return all(arguments).then(function(args) {
            var result = handler.apply(thisArg, args);
            if (isGeneratorFunction(result) || isGenerator(result)) {
                return co.call(thisArg, result);
            }
            return result;
        });
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.common" id="apidoc.module.hprose.common">module hprose.common</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.common.Completer" id="apidoc.element.hprose.common.Completer">
        function <span class="apidocSignatureSpan">hprose.common.</span>Completer
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Completer() {
    var future = new Future();
    Object.defineProperties(this, {
        future: { value: future },
        complete: { value: future.resolve },
        completeError: { value: future.reject },
        isCompleted: { get: function() {
            return ( future._state !== PENDING );
        } }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.common.Future" id="apidoc.element.hprose.common.Future">
        function <span class="apidocSignatureSpan">hprose.common.</span>Future
        <span class="apidocSignatureSpan">(computation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Future(computation) {
    var self = this;
    Object.defineProperties(this, {
        _subscribers: { value: [] },
        resolve: { value: this.resolve.bind(this) },
        reject: { value: this.reject.bind(this) }
    });
    if (typeof computation === &#x27;function&#x27;) {
        process.nextTick(function() {
            try {
                self.resolve(computation());
            }
            catch(e) {
                self.reject(e);
            }
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.filter" id="apidoc.module.hprose.filter">module hprose.filter</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.filter.JSONRPCClientFilter" id="apidoc.element.hprose.filter.JSONRPCClientFilter">
        function <span class="apidocSignatureSpan">hprose.filter.</span>JSONRPCClientFilter
        <span class="apidocSignatureSpan">(version)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONRPCClientFilter(version) {
    this.version = version || &#x27;2.0&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.filter.JSONRPCServiceFilter" id="apidoc.element.hprose.filter.JSONRPCServiceFilter">
        function <span class="apidocSignatureSpan">hprose.filter.</span>JSONRPCServiceFilter
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONRPCServiceFilter() {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.io" id="apidoc.module.hprose.io">module hprose.io</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.io.BytesIO" id="apidoc.element.hprose.io.BytesIO">
        function <span class="apidocSignatureSpan">hprose.io.</span>BytesIO
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">n/a</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.io.RawReader" id="apidoc.element.hprose.io.RawReader">
        function <span class="apidocSignatureSpan">hprose.io.</span>RawReader
        <span class="apidocSignatureSpan">(stream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RawReader(stream) {
    Object.defineProperties(this, {
        stream: { value : stream },
        readRaw: { value: function() { return readRaw(stream); } }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.io.Reader" id="apidoc.element.hprose.io.Reader">
        function <span class="apidocSignatureSpan">hprose.io.</span>Reader
        <span class="apidocSignatureSpan">(stream, simple, useHarmonyMap)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Reader(stream, simple, useHarmonyMap) {
    RawReader.call(this, stream);
    this.useHarmonyMap = !!useHarmonyMap;
    Object.defineProperties(this, {
        classref: { value: [] },
        refer: { value: simple ? fakeReaderRefer : realReaderRefer() }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.io.Writer" id="apidoc.element.hprose.io.Writer">
        function <span class="apidocSignatureSpan">hprose.io.</span>Writer
        <span class="apidocSignatureSpan">(stream, simple)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Writer(stream, simple) {
    Object.defineProperties(this, {
        stream: { value: stream },
        _classref: { value: Object.create(null), writable: true },
        _fieldsref: { value: [], writable: true },
        _refer: { value: simple ? fakeWriterRefer : realWriterRefer(stream) }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.regenerator_runtime" id="apidoc.module.hprose.regenerator_runtime">module hprose.regenerator_runtime</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.regenerator_runtime.async" id="apidoc.element.hprose.regenerator_runtime.async">
        function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>async
        <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">async = function (innerFn, outerFn, self, tryLocsList) {
  var iter = new AsyncIterator(
    wrap(innerFn, outerFn, self, tryLocsList)
  );

  return runtime.isGeneratorFunction(outerFn)
    ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.regenerator_runtime.awrap" id="apidoc.element.hprose.regenerator_runtime.awrap">
        function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>awrap
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">awrap = function (arg) {
  return new AwaitArgument(arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
};

// Within the body of any async function, `await x` is transformed to
// `yield regeneratorRuntime.<span class="apidocCodeKeywordSpan">awrap</span>(x)`, so that the runtime can test
// `value instanceof AwaitArgument` to determine if the yielded value is
// meant to be awaited. Some may consider the name of this method too
// cutesy, but they are curmudgeons.
runtime.awrap = function(arg) {
  return new AwaitArgument(arg);
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.regenerator_runtime.isGeneratorFunction" id="apidoc.element.hprose.regenerator_runtime.isGeneratorFunction">
        function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>isGeneratorFunction
        <span class="apidocSignatureSpan">(genFun)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isGeneratorFunction = function (genFun) {
  var ctor = typeof genFun === &#x22;function&#x22; &#x26;&#x26; genFun.constructor;
  return ctor
    ? ctor === GeneratorFunction ||
      // For the native GeneratorFunction constructor, the best we can
      // do is to check its .name property.
      (ctor.displayName || ctor.name) === &#x22;GeneratorFunction&#x22;
    : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// AsyncIterator objects; they just return a Promise for the value of
// the final result produced by the iterator.
runtime.async = function(innerFn, outerFn, self, tryLocsList) {
  var iter = new AsyncIterator(
    wrap(innerFn, outerFn, self, tryLocsList)
  );

  return runtime.<span class="apidocCodeKeywordSpan">isGeneratorFunction</span>(outerFn)
    ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
};

function makeInvokeMethod(innerFn, self, context) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.regenerator_runtime.keys" id="apidoc.element.hprose.regenerator_runtime.keys">
        function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>keys
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keys = function (object) {
  var keys = [];
  for (var key in object) {
    keys.push(key);
  }
  keys.reverse();

  // Rather than returning an object with a next method, we keep
  // things simple and return the next function itself.
  return function next() {
    while (keys.length) {
      var key = keys.pop();
      if (key in object) {
        next.value = key;
        next.done = false;
        return next;
      }
    }

    // To avoid creating an additional object, we just hang the .value
    // and .done properties off the next function object itself. This
    // also ensures that the minifier will not anonymize the function.
    next.done = true;
    return next;
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        var detector = new Future();
        topics[id].messages.push({ detector: detector, result: result });
        setTimer(topics, topic, id);
        return detector;
    }
}
function idlist(topic) {
    return Object.<span class="apidocCodeKeywordSpan">keys</span>(getTopics(topic));
}
function exist(topic, id) {
    return id in getTopics(topic);
}
function broadcast(topic, result, callback) {
    multicast(topic, idlist(topic), result, callback);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.regenerator_runtime.mark" id="apidoc.element.hprose.regenerator_runtime.mark">
        function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>mark
        <span class="apidocSignatureSpan">(genFun)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mark = function (genFun) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
  } else {
    genFun.__proto__ = GeneratorFunctionPrototype;
    if (!(toStringTagSymbol in genFun)) {
      genFun[toStringTagSymbol] = &#x22;GeneratorFunction&#x22;;
    }
  }
  genFun.prototype = Object.create(Gp);
  return genFun;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this._length = a[1];
    break;
case 3:
    this._bytes = new Uint8Array(a[0], a[1], a[2]);
    this._length = a[2];
    break;
}
this.<span class="apidocCodeKeywordSpan">mark</span>();
}

Object.defineProperties(BytesIO.prototype, {
_bytes: { value: null, writable: true },
_length: { value: 0, writable: true },
_wmark: { value: 0, writable: true },
_off: { value: 0, writable: true },
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.regenerator_runtime.values" id="apidoc.element.hprose.regenerator_runtime.values">
        function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>values
        <span class="apidocSignatureSpan">(iterable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function values(iterable) {
  if (iterable) {
    var iteratorMethod = iterable[iteratorSymbol];
    if (iteratorMethod) {
      return iteratorMethod.call(iterable);
    }

    if (typeof iterable.next === &#x22;function&#x22;) {
      return iterable;
    }

    if (!isNaN(iterable.length)) {
      var i = -1, next = function next() {
        while (++i &#x3c; iterable.length) {
          if (hasOwn.call(iterable, i)) {
            next.value = iterable[i];
            next.done = false;
            return next;
          }
        }

        next.value = undefined;
        next.done = true;

        return next;
      };

      return next.next = next;
    }
  }

  // Return an iterator with no values.
  return { next: doneResult };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.regenerator_runtime.wrap" id="apidoc.element.hprose.regenerator_runtime.wrap">
        function <span class="apidocSignatureSpan">hprose.regenerator_runtime.</span>wrap
        <span class="apidocSignatureSpan">(innerFn, outerFn, self, tryLocsList)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function wrap(innerFn, outerFn, self, tryLocsList) {
  // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
  var protoGenerator = outerFn &#x26;&#x26; outerFn.prototype instanceof Generator ? outerFn : Generator;
  var generator = Object.create(protoGenerator.prototype);
  var context = new Context(tryLocsList || []);

  // The ._invoke method unifies the implementations of the .next,
  // .throw, and .return methods.
  generator._invoke = makeInvokeMethod(innerFn, self, context);

  return generator;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.hprose.server" id="apidoc.module.hprose.server">module hprose.server</a></h1>


    <h2>
        <a href="#apidoc.element.hprose.server.HttpServer" id="apidoc.element.hprose.server.HttpServer">
        function <span class="apidocSignatureSpan">hprose.server.</span>HttpServer
        <span class="apidocSignatureSpan">(port, hostname, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpServer(port, hostname, tlsOptions) {
    HttpService.call(this);

    var self = this;
    var server = (tlsOptions ?
        https.createServer(tlsOptions, self.handle) :
        http.createServer(self.handle));

    server.on(&#x27;clientError&#x27;, function (e, socket) {
        var context = { server: server, socket: socket, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(port, hostname);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.HttpService" id="apidoc.element.hprose.server.HttpService">
        function <span class="apidocSignatureSpan">hprose.server.</span>HttpService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function HttpService() {
    Service.call(this);

    var _onSendHeader = null;
    var _crossDomain = true;
    var _P3P = true;
    var _get = true;
    var _origins = {};
    var _origincount = 0;
    var _crossDomainXmlFile = null;
    var _crossDomainXmlContent = null;
    var _clientAccessPolicyXmlFile = null;
    var _clientAccessPolicyXmlContent = null;
    var _lastModified = (new Date()).toUTCString();
    var _etag = &#x27;&#x22;&#x27; + Math.floor(Math.random() * 2147483647).toString(16) +
                &#x27;:&#x27; + Math.floor(Math.random() * 2147483647).toString(16) + &#x27;&#x22;&#x27;;

    var self = this;

    function getSendHeader() {
        return _onSendHeader;
    }

    function setSendHeader(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendHeader = value;
        }
        else {
            throw new Error(&#x27;onSendHeader must be a function or null.&#x27;);
        }
    }

    function crossDomainXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/crossdomain.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _crossDomainXmlContent.length);
                response.write(_crossDomainXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function clientAccessPolicyXmlHandler(request, response) {
        if (request.url.toLowerCase() === &#x27;/clientaccesspolicy.xml&#x27;) {
            if (request.headers[&#x27;if-modified-since&#x27;] === _lastModified &#x26;&#x26;
                request.headers[&#x27;if-none-match&#x27;] === _etag) {
                response.statusCode = 304;
            }
            else {
                response.setHeader(&#x27;Last-Modified&#x27;, _lastModified);
                response.setHeader(&#x27;Etag&#x27;, _etag);
                response.setHeader(&#x27;Content-Type&#x27;, &#x27;text/xml&#x27;);
                response.setHeader(&#x27;Content-Length&#x27;, _clientAccessPolicyXmlContent.length);
                response.write(_clientAccessPolicyXmlContent);
            }
            response.end();
            return true;
        }
        return false;
    }

    function sendHeader(context) {
        var resp = context.response;
        resp.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);
        if (_P3P) {
            resp.setHeader(&#x27;P3P&#x27;,
                &#x27;CP=&#x22;CAO DSP COR CUR ADM DEV TAI PSA PSD IVAi IVDi &#x27; +
                &#x27;CONi TELo OTPi OUR DELi SAMi OTRi UNRi PUBi IND PHY ONL &#x27; +
                &#x27;UNI PUR FIN COM NAV INT DEM CNT STA POL HEA PRE GOV&#x22;&#x27;);
        }
        if (_crossDomain) {
            var origin = context.request.headers.origin;
            if (origin &#x26;&#x26; origin !== &#x27;null&#x27;) {
                if (_origincount === 0 || _origins[origin]) {
                    resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, origin);
                    resp.setHeader(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;);
                }
            }
            else {
                resp.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);
            }
        }
        self.emit(&#x27;sendHeader&#x27;, context);
        if (_onSendHeader !== null) {
            _onSendHeader(context);
        }
    }

    function isCrossDomainEnabled() {
        return _crossDomain;
    }

    function setCrossDomainEnabled(value) {
        _crossDomain = !!value;
    }

    function isP3PEnabled() {
        return _P3P;
    }

    function setP3PEnabled(value) {
        _P3P = !!value;
    }

    function isGetEnabled() {
        return _get;
    }

    function setGetEnabled(value) {
        _get = !!value;
    }

    function addAccessControlAllowOrigin(origin) {
        if (!_origins[origin]) {
            _origins[origin] = true;
            _origincount++;
        }
    }

    function removeAcces ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.Server" id="apidoc.element.hprose.server.Server">
        function <span class="apidocSignatureSpan">hprose.server.</span>Server
        <span class="apidocSignatureSpan">(uri, tlsOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Server(uri, tlsOptions, handler) {
    return create(uri, tlsOptions, handler);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    catch(e) {}
}

httpserver.on(&#x27;clientError&#x27;, onerror);

function start() {
    httpserver.listen(port, host);
    server = new ws.<span class="apidocCodeKeywordSpan">Server</span>(options);
    server.on(&#x27;connection&#x27;, self.wsHandle);
    server.on(&#x27;error&#x27;, onerror);
}
function stop() {
    server.close();
    httpserver.close();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.Service" id="apidoc.element.hprose.server.Service">
        function <span class="apidocSignatureSpan">hprose.server.</span>Service
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Service() {
    EventEmitter.call(this);

    var _calls                  = {},
        _names                  = [],
        _filters                = [],
        _onBeforeInvoke         = null,
        _onAfterInvoke          = null,
        _onSendError            = null,
        _timeout                = 120000,
        _heartbeat              = 3000,
        _errorDelay             = 10000,
        _simple                 = false,
        _debug                  = false,
        _passContext            = false,
        _topics                 = {},
        _events                 = {},
        _invokeHandler          = invokeHandler,
        _beforeFilterHandler    = beforeFilterHandler,
        _afterFilterHandler     = afterFilterHandler,
        _invokeHandlers         = [],
        _beforeFilterHandlers   = [],
        _afterFilterHandlers    = [],

        self = this;

    function inputFilter(data, context) {
        for (var i = _filters.length - 1; i &#x3e;= 0; i--) {
            data = _filters[i].inputFilter(data, context);
        }
        return data;
    }

    function outputFilter(data, context) {
        for (var i = 0, n = _filters.length; i &#x3c; n; i++) {
            data = _filters[i].outputFilter(data, context);
        }
        return data;
    }

    function getBeforeInvoke() {
        return _onBeforeInvoke;
    }

    function setBeforeInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onBeforeInvoke = value;
        }
        else {
            throw new Error(&#x27;onBeforeInvoke must be a function or null.&#x27;);
        }
    }

    function getAfterInvoke() {
        return _onAfterInvoke;
    }

    function setAfterInvoke(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAfterInvoke = value;
        }
        else {
            throw new Error(&#x27;onAfterInvoke must be a function or null.&#x27;);
        }
    }

    function getSendError() {
        return _onSendError;
    }

    function setSendError(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onSendError = value;
        }
        else {
            throw new Error(&#x27;onSendError must be a function or null.&#x27;);
        }
    }

    function sendError(error, context) {
        if (!isError(error)) {
            error = new Error(error);
        }
        try {
            self.emit(&#x27;sendError&#x27;, error, context);
            if (_onSendError !== null) {
                var e = _onSendError(error, context);
                if (isError(e)) {
                    error = e;
                }
            }
        }
        catch(e) {
            error = e;
        }
        var stream = new BytesIO();
        var writer = new Writer(stream, true);
        stream.writeByte(Tags.TagError);
        writer.writeString(_debug ? error.stack : error.message);
        return stream;
    }

    function endError(error, context) {
        var stream = sendError(error, context);
        stream.writeByte(Tags.TagEnd);
        return stream.bytes;
    }

    function beforeInvoke(name, args, context) {
        try {
            self.emit(&#x27;beforeInvoke&#x27;, name, args, context.byref, context);
            if (_onBeforeInvoke !== null) {
                var value = _onBeforeInvoke(name, args, context.byref, context);
                if (isError(value)) { throw value; }
                if (Future.isPromise(value)) {
                    return value.then(function(e) {
                        if (isError(e)) { throw e; }
                        return invoke(name, args, context);
                    }).then(null, function(e) {
                        return sendError(e, context);
                    });
                }
            }
            return invoke(name, args, context).then(null, function(e) {
                return sendError(e, context);
            });
        }
        catch (e) {
            return sendError(e, context);
        }
    }

    function invokeHandler(name, args, context) {
        if ((&#x27;*&#x27; in _calls) &#x26;&#x26; (context.method === _calls[&#x27;*&#x27; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.SocketServer" id="apidoc.element.hprose.server.SocketServer">
        function <span class="apidocSignatureSpan">hprose.server.</span>SocketServer
        <span class="apidocSignatureSpan">(options, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketServer(options, tlsOptions) {
    SocketService.call(this);
    var self = this;
    var server = (tlsOptions ?
        tls.createServer(tlsOptions, self.handle) :
        net.createServer(self.handle));

    server.on(&#x27;error&#x27;, function (e) {
        var context = { server: server, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(options);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.SocketService" id="apidoc.element.hprose.server.SocketService">
        function <span class="apidocSignatureSpan">hprose.server.</span>SocketService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketService() {
    Service.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(socket, data, id) {
        var p = (id === null ? 4 : 8);
        var n = data.length;
        var buf = new Buffer(p + n);
        if (p === 8) {
            buf.writeInt32BE(n | 0x80000000, 0);
            buf.writeInt32BE(id, 4);
        }
        else {
            buf.writeUInt32BE(n, 0);
        }
        for (var i = 0; i &#x3c; n; i++) {
            buf[i + p] = data[i];
        }
        socket.write(buf);
    }

    function send(socket, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(socket, data, id); });
        }
        else {
            _send(socket, data, id);
        }
    }

    function run(socket, data, id) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        data = self.defaultHandle(data, context);
        send(socket, data, id);
    }

    function receive(socket) {
        var bytes = new BytesIO();
        var headerLength = 4;
        var dataLength = -1;
        var id = null;
        socket.on(&#x27;data&#x27;, function(chunk) {
            bytes.write(chunk);
            while (true) {
                if ((dataLength &#x3c; 0) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    dataLength = bytes.readInt32BE();
                    if ((dataLength &#x26; 0x80000000) !== 0) {
                        dataLength &#x26;= 0x7fffffff;
                        headerLength = 8;
                    }
                }
                if ((headerLength === 8) &#x26;&#x26; (id === null) &#x26;&#x26; (bytes.length &#x3e;= headerLength)) {
                    id = bytes.readInt32BE();
                }
                if ((dataLength &#x3e;= 0) &#x26;&#x26; ((bytes.length - headerLength) &#x3e;= dataLength)) {
                    var data = bytes.read(dataLength);
                    run(socket, data, id);
                    bytes.trunc();
                    dataLength = -1;
                    headerLength = 4;
                    id = null;
                }
                else {
                    break;
                }
            }
        });
    }

    function handle(socket) {
        var context = {
            server: self.server,
            socket: socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            socket.end();
            return;
        }
        socket.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;, context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        socket.on(&#x27;end&#x27;, noop);
        socket.on(&#x27;error&#x27;, function(e) {
            try {
                if (e.code != &#x22;EPIPE&#x22;) {
                    self.emit(&#x27;sendError&#x27;, e, context);
                    if (self.onSendError) {
                        self.onSendError(e, context);
                    }
                }
            }
            catch(e) {}
        });
        socket.setTimeout(self.timeout);
        receive(socket);
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        handle: { value: handle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.TcpServer" id="apidoc.element.hprose.server.TcpServer">
        function <span class="apidocSignatureSpan">hprose.server.</span>TcpServer
        <span class="apidocSignatureSpan">(options, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketServer(options, tlsOptions) {
    SocketService.call(this);
    var self = this;
    var server = (tlsOptions ?
        tls.createServer(tlsOptions, self.handle) :
        net.createServer(self.handle));

    server.on(&#x27;error&#x27;, function (e) {
        var context = { server: server, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(options);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.UnixServer" id="apidoc.element.hprose.server.UnixServer">
        function <span class="apidocSignatureSpan">hprose.server.</span>UnixServer
        <span class="apidocSignatureSpan">(options, tlsOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocketServer(options, tlsOptions) {
    SocketService.call(this);
    var self = this;
    var server = (tlsOptions ?
        tls.createServer(tlsOptions, self.handle) :
        net.createServer(self.handle));

    server.on(&#x27;error&#x27;, function (e) {
        var context = { server: server, userdata:{} };
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    });

    function start() {
        server.listen(options);
    }
    function stop() {
        server.close();
    }
    function listen() {
        server.listen.apply(server, arguments);
    }
    function close(callback) {
        server.close(callback);
    }

    Object.defineProperties(this, {
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.WebSocketServer" id="apidoc.element.hprose.server.WebSocketServer">
        function <span class="apidocSignatureSpan">hprose.server.</span>WebSocketServer
        <span class="apidocSignatureSpan">(options, tlsOptions, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketServer(options, tlsOptions, handler) {
    WebSocketService.call(this);
    var self = this;
    if (!handler) handler = this.handle;
    var httpserver = tlsOptions ?
        https.createServer(tlsOptions, handler) :
        http.createServer(handler);
    var host = options.host;
    var port = options.port;
    delete options.host;
    delete options.port;
    options.server = httpserver;
    options.perMessageDeflate = false;
    var server = null;

    function onerror(e, socket) {
        var context = {
            httpserver: httpserver,
            server: self.server,
            userdata:{}
        };
        if (socket) { context.socket = socket; }
        try {
            self.emit(&#x27;sendError&#x27;, e, context);
            if (self.onSendError) {
                self.onSendError(e, context);
            }
        }
        catch(e) {}
    }

    httpserver.on(&#x27;clientError&#x27;, onerror);

    function start() {
        httpserver.listen(port, host);
        server = new ws.Server(options);
        server.on(&#x27;connection&#x27;, self.wsHandle);
        server.on(&#x27;error&#x27;, onerror);
    }
    function stop() {
        server.close();
        httpserver.close();
    }
    function listen() {
        httpserver.listen.apply(httpserver, arguments);
        server = new ws.Server(options);
        server.on(&#x27;connection&#x27;, self.wsHandle);
        server.on(&#x27;error&#x27;, onerror);
    }
    function close(callback) {
        server.close();
        httpserver.close(callback);
    }

    Object.defineProperties(this, {
        httpserver: { get: function () { return httpserver; } },
        server: { get: function () { return server; } },
        start: { value: start },
        stop: { value: stop },
        listen: { value: listen },
        close: { value: close }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.hprose.server.WebSocketService" id="apidoc.element.hprose.server.WebSocketService">
        function <span class="apidocSignatureSpan">hprose.server.</span>WebSocketService
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WebSocketService() {
    HttpService.call(this);

    var _onAccept = null;
    var _onClose = null;

    var self = this;

    function getAccept() {
        return _onAccept;
    }

    function setAccept(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onAccept = value;
        }
        else {
            throw new Error(&#x27;onAccept must be a function or null.&#x27;);
        }
    }

    function getClose() {
        return _onClose;
    }

    function setClose(value) {
        if (value === null || typeof value === &#x27;function&#x27;) {
            _onClose = value;
        }
        else {
            throw new Error(&#x27;onClose must be a function or null.&#x27;);
        }
    }

    function _send(ws, data, id) {
        var bytes = new BytesIO();
        bytes.writeInt32BE(id);
        if (data.constructor === String) {
            bytes.writeString(data);
        }
        else {
            bytes.write(data);
        }
        try {
            ws.send(bytes.bytes, {
                binary: true,
                compress: false
            });
        }
        catch (e) {
            ws.emit(&#x27;error&#x27;, e);
        }
    }

    function send(ws, data, id) {
        if (Future.isFuture(data)) {
            data.then(function(data) { _send(ws, data, id); });
        }
        else {
            _send(ws, data, id);
        }
    }

    function wsHandle(ws) {
        var context = {
            httpserver: self.httpserver,
            server: self.server,
            websocket: ws,
            socket: ws._socket,
            userdata: {}
        };
        try {
            self.emit(&#x27;accept&#x27;, context);
            if (_onAccept) { _onAccept(context); }
        }
        catch(e) {
            ws.close();
            return;
        }
        ws.on(&#x27;close&#x27;, function() {
            try {
                self.emit(&#x27;close&#x27;,context);
                if (_onClose) { _onClose(context); }
            }
            catch(e) {}
        });
        ws.on(&#x27;error&#x27;, function(e) {
            try {
                self.emit(&#x27;sendError&#x27;, e, context);
                if (self.onSendError) {
                    self.onSendError(e, context);
                }
            }
            catch(e) {}
        });
        ws.on(&#x27;message&#x27;, function(data) {
            var bytes = new BytesIO(data);
            var id = bytes.readInt32BE();
            var request = bytes.read(bytes.length - 4);
            process.nextTick(function() {
                var context = {
                    httpserver: self.httpserver,
                    server: self.server,
                    websocket: ws,
                    socket: ws._socket,
                    userdata: {}
                };
                data = self.defaultHandle(request, context);
                send(ws, data, id);
            });
        });
    }
    Object.defineProperties(this, {
        onAccept: { get: getAccept, set: setAccept },
        onClose: { get: getClose, set: setClose },
        wsHandle: { value: wsHandle }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
